<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>平衡二叉树 (AVL)</title>
    <url>/algorithm/search/661.html</url>
    <content><![CDATA[<p>平衡二叉树 —— 任意结点的子树的高度差都小于等于 1 的一棵二叉排序树</p>
<a id="more"></a>

<p><strong>数据结构课代码实现 之 平衡二叉树</strong></p>
<h2 id="简要理解"><a href="#简要理解" class="headerlink" title="简要理解"></a>简要理解</h2><h3 id="二叉排序树的缺点"><a href="#二叉排序树的缺点" class="headerlink" title="二叉排序树的缺点"></a>二叉排序树的缺点</h3><p>二叉搜索树理想状态下与折半查找的效率相同</p>
<p>但是折半查找长度为 <code>n</code> 的表的判定树唯一，而拥有 <code>n</code> 个结点二叉搜索树的并不唯一</p>
<p>又含有 <code>n</code> 个结点的二叉搜索树的平均查找长度和树的形态有关</p>
<p>最差的情况下，如果先后插入关键字有序时，构成的二叉搜索树就会退化成一个单支树，数的深度为 <code>n</code>，平均查找长度会退化为 <code>(n + 1) / 2</code> （和顺序查找表相同）</p>
<p>因此需要在构成二叉排序树的过程中进行 “平衡化” 处理，成为二叉平衡树</p>
<h3 id="平衡二叉树的性质"><a href="#平衡二叉树的性质" class="headerlink" title="平衡二叉树的性质"></a>平衡二叉树的性质</h3><p>平衡二叉树具有如下性质：</p>
<ol>
<li>平衡二叉树可为空</li>
<li>如果平衡二叉树不为空树，则每个结点满足：<ol>
<li>左、右子树也分别为一棵平衡二叉树</li>
<li>左子树和右子树的深度之差的绝对值不超过 <code>1</code></li>
</ol>
</li>
</ol>
<p>平衡二叉树中每个结点都存在一个 <strong>平衡因子</strong>BF (Balance Factor) 定义为该结点的左子树的深度减去它右子树的深度，易知平衡二叉树上所有结点的平衡因子只可能为 -1、0 和 1</p>
<p>在插入时，可以用结点的 BF 绝对值大于 1 来这个确定以此结点为根结点的最小不平衡子树</p>
<p>我们可以对这个最小不平衡子树进行 “旋转” 操作来使其恢复 “平衡” 并且不破坏其排序性</p>
<h3 id="四个旋转操作"><a href="#四个旋转操作" class="headerlink" title="四个旋转操作"></a>四个旋转操作</h3><p>总结了四个 “旋转” 操作，可以应对任何插入与删除结点时失衡的情况：</p>
<h4 id="单向右旋（LL-型）："><a href="#单向右旋（LL-型）：" class="headerlink" title="单向右旋（LL 型）："></a>单向右旋（LL 型）：</h4><p><img src="/images/AVL/LL.jpg"></p>
<h4 id="单向左旋（RR-型）："><a href="#单向左旋（RR-型）：" class="headerlink" title="单向左旋（RR  型）："></a>单向左旋（RR  型）：</h4><p><img src="/images/AVL/RR.jpg"></p>
<h4 id="先左旋后右旋（LR-型）："><a href="#先左旋后右旋（LR-型）：" class="headerlink" title="先左旋后右旋（LR 型）："></a>先左旋后右旋（LR 型）：</h4><p><img src="/images/AVL/LR.jpg"></p>
<h4 id="先右旋后左旋（RL-型）："><a href="#先右旋后左旋（RL-型）：" class="headerlink" title="先右旋后左旋（RL 型）："></a>先右旋后左旋（RL 型）：</h4><p><img src="/images/AVL/RL.jpg"></p>
<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>插入操作使用了递归的方法插入结点，具体过程是先递归查找到插入结点的位置，然后插入结点后，最后一层递归结束，开始一层一层地向上检查父结点是否因为此次插入结点的行为导致失衡 (平衡因子 bf 的绝对值大于 1)，如果失衡则进行相应的平衡操作，直到检查至根节点</p>
<p>插入操作中需要设置一个 <code>bool</code>型变量 <code>taller</code> 来记录每一层递归中进行平衡化操作 或者 不进行平衡化操作的情况下相应子树的高度是否变高的信息 (在插入结点时，插入的结点所在的子树的高度由 <code>0</code> 变为了 <code>1</code>)，如果增高则由向上一层递归中的结点的 bf 信息判断失衡与否，同时也要更新此结点的 bf 信息与此层递归中相应子树的 <code>taller</code> 信息</p>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>具体思想与插入操作类似，使用递归查找到删除结点的位置，删除的过程也与二叉排序树的删除操作类似，分为两种情况</p>
<ol>
<li><p>该结点只有左右子树，则将该结点的左 (右) 子树的根结点代替此结点即可，不会破坏子树平衡二叉树性质，但需要从要删除的结点开始一层一层地向上检查父结点是否因为此次删除结点的行为导致失衡 (平衡因子 bf 的绝对值大于 1)，如果失衡则进行相应的平衡操作，直到检查至根节点</p>
<p>（这里有个技巧，删除左子树的一个结点导致的失衡，等价于在右子树上插入一个结点导致的失衡，但是在平衡时有一个特殊的情况，在代码中我会注释）</p>
</li>
<li><p>该结点既有左子树又有右子树，则需要利用二叉排序树的性质（中序输出这棵二叉树即为一个由小到大的序列），所以删除该结点，相当于用删除结点的 前驱 或者 后继结点 的 <code>data</code>值 来代替删除结点的 <code>data</code>值，然后删除 前驱 或者 后继结点</p>
<p>所以就将删除既有左子树又有右子树的结点的问题转化成了删除相应的前驱结点的问题 (我写的是前驱结点，推荐你写后继结点，加深印象)，同时平衡化的处理则同时转化成了解决删除相应的前驱结点产生的不平衡现象的解决问题，易知前驱结点必然不会拥有右子树，所以就转化成了情况一的解决方案</p>
</li>
</ol>
<p>相应地，删除操作中需要设置一个 <code>bool</code>型变量 <code>lower</code> 来记录每一层递归中进行平衡化操作 或者 不进行平衡化操作的情况下相应子树的高度是否变低的信息 (在删除结点时，删除的结点所在的子树的高度由 <code>1</code> 变为了 <code>0</code>)，如果变低则由向上一层递归中的结点的 bf 信息判断失衡与否，同时也要更新此结点的 bf 信息与此层递归中相应子树的 <code>lower</code> 信息</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LH + 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EH 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RH - 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> bf; <span class="comment">// 平衡化因子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BSTNode, *BSTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnOrder</span><span class="params">(BSTree T, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> cen, <span class="keyword">int</span> fa)</span> <span class="comment">// 中序输出一下结果</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        OnOrder(T-&gt;lchild, <span class="number">1</span>, <span class="number">0</span>, cen + <span class="number">1</span>, T-&gt;data); </span><br><span class="line">        <span class="keyword">if</span>(fa == <span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;根节点&quot;</span> &lt;&lt; <span class="string">&quot; 该点为：&quot;</span> &lt;&lt; T-&gt;data &lt;&lt; <span class="string">&quot; 层数为：&quot;</span> &lt;&lt; cen &lt;&lt; <span class="string">&quot; bf为&quot;</span> &lt;&lt; T-&gt;bf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;该点为：&quot;</span> &lt;&lt; T-&gt;data &lt;&lt; <span class="string">&quot; 该节点为 &quot;</span> &lt;&lt; fa &lt;&lt; <span class="string">&quot; 的左儿子&quot;</span> &lt;&lt; <span class="string">&quot; 层数为：&quot;</span> &lt;&lt; cen &lt;&lt; <span class="string">&quot; bf为&quot;</span> &lt;&lt; T-&gt;bf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(r)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;该点为：&quot;</span> &lt;&lt; T-&gt;data &lt;&lt; <span class="string">&quot; 该节点为 &quot;</span> &lt;&lt; fa &lt;&lt; <span class="string">&quot; 的右儿子&quot;</span> &lt;&lt; <span class="string">&quot; 层数为：&quot;</span> &lt;&lt; cen &lt;&lt; <span class="string">&quot; bf为&quot;</span> &lt;&lt; T-&gt;bf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        OnOrder(T-&gt;rchild, <span class="number">0</span>, <span class="number">1</span>, cen + <span class="number">1</span>, T-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EQ</span><span class="params">(<span class="keyword">int</span> key1, <span class="keyword">int</span> key2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key1 == key2)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LT</span><span class="params">(<span class="keyword">int</span> key1, <span class="keyword">int</span> key2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key1 &lt; key2)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R_Rotate</span><span class="params">(BSTree &amp;p)</span> <span class="comment">// 单向右旋操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BSTree lc = p-&gt;lchild;</span><br><span class="line">    p-&gt;lchild = lc-&gt;rchild;</span><br><span class="line">    lc-&gt;rchild = p;</span><br><span class="line">    p = lc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">L_Rotate</span><span class="params">(BSTree &amp;p)</span> <span class="comment">// 单向左旋操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BSTree rc = p-&gt;rchild;</span><br><span class="line">    p-&gt;rchild = rc-&gt;lchild;</span><br><span class="line">    rc-&gt;lchild = p;</span><br><span class="line">    p = rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LeftBalance</span><span class="params">(BSTree &amp;T)</span> <span class="comment">// 结点所在左子树失衡 两种情况</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BSTree lc = T-&gt;lchild;</span><br><span class="line">    <span class="keyword">switch</span> (lc-&gt;bf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> LH: <span class="comment">// 左儿子的左子树高 意味着在左儿子的左子树下插入了一个结点</span></span><br><span class="line">            T-&gt;bf = lc-&gt;bf = EH;</span><br><span class="line">            R_Rotate(T); <span class="comment">// 单向右旋</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RH: <span class="comment">// 左儿子的右子树高 意味着在左儿子的右子树下插入了一个结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            BSTree rd = lc-&gt;rchild;</span><br><span class="line">            <span class="keyword">switch</span> (rd-&gt;bf)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> LH:</span><br><span class="line">                    T-&gt;bf = RH;</span><br><span class="line">                    lc-&gt;bf = EH;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RH:</span><br><span class="line">                    T-&gt;bf = EH; <span class="comment">// 这里建议画图理解吧</span></span><br><span class="line">                    lc-&gt;bf = LH;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> EH:</span><br><span class="line">                    T-&gt;bf = EH;</span><br><span class="line">                    lc-&gt;bf = EH;</span><br><span class="line">            &#125; </span><br><span class="line">            rd-&gt;bf = EH;</span><br><span class="line">            L_Rotate(T-&gt;lchild); <span class="comment">// 先左旋后右旋</span></span><br><span class="line">            R_Rotate(T);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> EH: <span class="comment">// 这就是删除结点时才会出现的特殊情况 左儿子左右子树等高</span></span><br><span class="line">            T-&gt;bf = LH;</span><br><span class="line">            lc-&gt;bf = RH;</span><br><span class="line">            R_Rotate(T); <span class="comment">// 子树左子树比右子树高两个高度 直接单向右旋解决问题</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RightBalance</span><span class="params">(BSTree &amp;T)</span> <span class="comment">// 结点所在右子树失衡 两种情况</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BSTree rc = T-&gt;rchild;</span><br><span class="line">    <span class="keyword">switch</span> (rc-&gt;bf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> RH: <span class="comment">// 右儿子的右子树高 意味着在右儿子的右子树下插入了一个结点</span></span><br><span class="line">            T-&gt;bf = rc-&gt;bf = EH;</span><br><span class="line">            L_Rotate(T); <span class="comment">// 单向右旋</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LH: <span class="comment">// 右儿子的左子树高 意味着在右儿子的左子树下插入了一个结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            BSTree rd = rc-&gt;lchild;</span><br><span class="line">            <span class="keyword">switch</span> (rd-&gt;bf)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> LH:</span><br><span class="line">                    T-&gt;bf = EH;</span><br><span class="line">                    rc-&gt;bf = RH;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RH: <span class="comment">// 这里还是建议画图理解吧</span></span><br><span class="line">                    T-&gt;bf = LH;</span><br><span class="line">                    rc-&gt;bf = EH;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> EH:</span><br><span class="line">                    T-&gt;bf = EH;</span><br><span class="line">                    rc-&gt;bf = EH;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            rd-&gt;bf = EH;</span><br><span class="line">            R_Rotate(T-&gt;rchild); <span class="comment">// 先右旋后左旋</span></span><br><span class="line">            L_Rotate(T);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> EH: <span class="comment">// 这还是删除结点时才会出现的特殊情况 右儿子左右子树等高</span></span><br><span class="line">            T-&gt;bf = RH;</span><br><span class="line">            rc-&gt;bf = LH;</span><br><span class="line">            L_Rotate(T); <span class="comment">// 子树右子树比左子树高两个高度 直接单向左旋解决问题</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InsertAVL</span><span class="params">(BSTree &amp;T, <span class="keyword">int</span> key, <span class="keyword">bool</span> &amp;taller)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T) <span class="comment">// 在空指针上插入新的结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        T = (BSTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">        T-&gt;data = key;</span><br><span class="line">        T-&gt;lchild = T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        T-&gt;bf = EH;</span><br><span class="line">        taller = <span class="literal">true</span>; <span class="comment">// 新结点所在子树变高</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; <span class="comment">// 寻找插入位置的三种情况 当前结点的 data 等于 大于 小于 key</span></span><br><span class="line">        <span class="keyword">if</span>(EQ(key, T-&gt;data))</span><br><span class="line">        &#123;</span><br><span class="line">            taller = <span class="literal">false</span>; <span class="comment">// 存在要插入的结点 插入失败 不插入则 taller 置 false  </span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(LT(key, T-&gt;data))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!InsertAVL(T-&gt;lchild, key, taller))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果插入结点存在则 return 0</span></span><br><span class="line">            <span class="keyword">if</span>(taller) <span class="comment">// 正常情况下检查层次低的子树变高对这一层递归中的结点平衡性的影响</span></span><br><span class="line">                <span class="keyword">switch</span> (T-&gt;bf)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> LH:</span><br><span class="line">                        LeftBalance(T); <span class="comment">// 本来左子树就高还往左子树插结点  需要平衡化</span></span><br><span class="line">                        taller = <span class="literal">false</span>; <span class="comment">// 平衡化后此层递归的结点所在子树不会变高</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> EH:</span><br><span class="line">                        T-&gt;bf = LH; <span class="comment">// 本来左右子树等高 往左子树插结点 则左子树高</span></span><br><span class="line">                        taller = <span class="literal">true</span>; <span class="comment">// 所以此层递归的结点所在子树会变高</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> RH:</span><br><span class="line">                        T-&gt;bf = EH; <span class="comment">// 本来右子树高 往左子树插结点 则左右等高</span></span><br><span class="line">                        taller = <span class="literal">false</span>; <span class="comment">// 所以此层递归的结点所在子树不会变高</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!InsertAVL(T-&gt;rchild, key, taller))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(taller)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">switch</span> (T-&gt;bf)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> LH:</span><br><span class="line">                        T-&gt;bf = EH; <span class="comment">// 本来左子树就高 往右子树插结点 则左右等高</span></span><br><span class="line">                        taller = <span class="literal">false</span>; <span class="comment">// 所以此层递归的结点所在子树不会变高</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> EH:</span><br><span class="line">                        T-&gt;bf = RH; <span class="comment">// 本来左右子树等高 往右子树插结点 则右子树高</span></span><br><span class="line">                        taller = <span class="literal">true</span>; <span class="comment">// 所以此层递归的结点所在子树会变高</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> RH:</span><br><span class="line">                        RightBalance(T); <span class="comment">// 本来右子树就高还往右子树插结点 需要平衡化</span></span><br><span class="line">                        taller = <span class="literal">false</span>; <span class="comment">// 平衡化后此层递归的结点所在子树不会变高</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BSTree root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteAVL</span><span class="params">(BSTree &amp;T, <span class="keyword">int</span> key, <span class="keyword">bool</span> &amp;lower)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getRoot</span><span class="params">(BSTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    root = T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(BSTree &amp;p)</span> <span class="comment">// 删除操作 存在三种情况</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BSTree q;</span><br><span class="line">    <span class="keyword">if</span>(!p-&gt;lchild) <span class="comment">// 删除结点没有左子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;rchild; <span class="comment">// 直接用结点右子树的根结点代替此结点</span></span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!p-&gt;rchild) <span class="comment">// 删除结点没有右子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;lchild; <span class="comment">// 直接用结点左子树的根结点代替此结点</span></span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 删除结点既有左子树又有右子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        BSTree t = p; <span class="comment">// 删除前驱结点时失衡调整会更改 p指针 所指向的结点 此处保存一下</span></span><br><span class="line">        BSTree s = p-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span>(s-&gt;rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            q = s;</span><br><span class="line">            s = s-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        BSTree tmp = s-&gt;lchild; <span class="comment">// 删除前驱结点s 需要保存 s的左儿子</span></span><br><span class="line">        <span class="keyword">int</span> x = s-&gt;data; <span class="comment">// 以及保存 s的data</span></span><br><span class="line">        <span class="keyword">bool</span> lower = <span class="literal">false</span>;</span><br><span class="line">        DeleteAVL(root, x, lower);</span><br><span class="line">        <span class="keyword">if</span>(q != t)</span><br><span class="line">            q-&gt;rchild = tmp;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            q-&gt;lchild = tmp;</span><br><span class="line">        t-&gt;data = x; <span class="comment">// 用前驱结点的 data 代替 删除结点的data</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteAVL</span><span class="params">(BSTree &amp;T, <span class="keyword">int</span> key, <span class="keyword">bool</span> &amp;lower)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T) </span><br><span class="line">    &#123;</span><br><span class="line">        lower = <span class="literal">false</span>; <span class="comment">// 找不到删除的结点 lower 置 false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 删除失败 返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; <span class="comment">// 寻找删除结点的三种情况 当前结点的 data 等于 大于 小于 key</span></span><br><span class="line">        <span class="keyword">if</span>(EQ(key, T-&gt;data))</span><br><span class="line">        &#123;</span><br><span class="line">            Delete(T); <span class="comment">// 找到删除的结点 进行删除操作</span></span><br><span class="line">            lower = <span class="literal">true</span>; <span class="comment">// 删除结点所在的相应子树高度变低</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(LT(key, T-&gt;data))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!DeleteAVL(T-&gt;lchild, key, lower))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果不存在删除结点存在则 return false</span></span><br><span class="line">            <span class="keyword">if</span>(lower)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">switch</span> (T-&gt;bf)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> EH:</span><br><span class="line">                        T-&gt;bf = RH; <span class="comment">// 本来左右子树等高 删除左子树上结点 右子树高</span></span><br><span class="line">                        lower = <span class="literal">false</span>; <span class="comment">// 所以此层递归的结点所在子树不会变低</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> LH:</span><br><span class="line">                        T-&gt;bf = EH; <span class="comment">// 本来左子树高 删除左子树上结点 左右子树等高</span></span><br><span class="line">                        lower = <span class="literal">true</span>; <span class="comment">// 所以此层递归的结点所在子树会变低</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> RH:</span><br><span class="line">                        RightBalance(T); <span class="comment">// 本来右子树高 删除左子树上结点 需要平衡化</span></span><br><span class="line">                        lower = <span class="literal">true</span>; <span class="comment">// 平衡化后此层递归的结点所在子树会变低</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!DeleteAVL(T-&gt;rchild, key, lower))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果不存在删除结点存在则 return false</span></span><br><span class="line">            <span class="keyword">if</span>(lower)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">switch</span> (T-&gt;bf)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> EH:</span><br><span class="line">                        T-&gt;bf = LH; <span class="comment">// 本来左右子树等高 删除右子树上结点 左子树高</span></span><br><span class="line">                        lower = <span class="literal">false</span>; <span class="comment">// 所以此层递归的结点所在子树不会变低</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> RH:</span><br><span class="line">                        T-&gt;bf = EH; <span class="comment">// 本来右子树高 删除右子树上结点 左右子树等高</span></span><br><span class="line">                        lower = <span class="literal">true</span>; <span class="comment">// 所以此层递归的结点所在子树会变低</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> LH:</span><br><span class="line">                        LeftBalance(T); <span class="comment">// 本来左子树高 删除右子树上结点 需要平衡化</span></span><br><span class="line">                        lower = <span class="literal">true</span>; <span class="comment">// 平衡化后此层递归的结点所在子树会变低</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BSTree T;</span><br><span class="line">    T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入树的结点数：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;依次输入每个结点的 data 值，空格分开&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; key;</span><br><span class="line">        <span class="keyword">bool</span> taller = <span class="literal">false</span>;</span><br><span class="line">        InsertAVL(T, key, taller);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;构建的平衡二叉树为：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    OnOrder(T, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入删除的结点数：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; num; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;依次输入删除的结点的data值，空格分开&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        getRoot(T);</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; key;</span><br><span class="line">        <span class="keyword">bool</span> lower = <span class="literal">false</span>;</span><br><span class="line">        DeleteAVL(T, key, lower);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;删除后的平衡二叉树为：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    OnOrder(T, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>查找</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title>待更新二叉搜索树 平衡二叉树 红黑树 B树 B+树</title>
    <url>/me/status-update/article-update/657.html</url>
    <content><![CDATA[<p>请自己手写一遍！</p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>状态更新</category>
        <category>文章更新</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>状态更新</tag>
        <tag>文章更新</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark on Yarn环境配置以及Hadoop HA配置中的问题</title>
    <url>/develop/spark/690.html</url>
    <content><![CDATA[<p>记录配置Spark on Yarn环境的过程，以及之前Hadoop HA部署存在的问题</p>
<a id="more"></a>

<p>上接：<a href="https://www.woolym.com/develop/hadoop/689.html">https://www.woolym.com/develop/hadoop/689.html</a></p>
<h2 id="Spark-on-Yarn环境搭建"><a href="#Spark-on-Yarn环境搭建" class="headerlink" title="Spark on Yarn环境搭建"></a>Spark on Yarn环境搭建</h2><p>我使用的的是</p>
<ul>
<li>spark-3.1.3-bin-without-hadoop</li>
<li>Python-3.7.11（pyspark 使用）</li>
</ul>
<p>Python环境建立使用 MakeFile 编译后做一下软链接，pyspark 运行需要 PATH 中有 python3</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>我把 SPARK_HOME 和 PYTHONPATH 配置到环境变量中了</p>
<p>这里设置 PYTHONPATH 是为了在 BASH 中使用 pyspark import pyspark</p>
<p>建议在profile.d中新建.sh设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export SPARK_HOME=/usr/local/spark-3.1.3-bin-without-hadoop</span><br><span class="line">export PATH=$PATH:$SPARK_HOME/bin</span><br><span class="line">export PYTHONPATH=$SPARK_HOME/python:$SPARK_HOME/python/lib/py4j-0.10.9-src.zip:$PYTHONPATH</span><br></pre></td></tr></table></figure>

<h3 id="Spark配置文件修改"><a href="#Spark配置文件修改" class="headerlink" title="Spark配置文件修改"></a>Spark配置文件修改</h3><h4 id="spark-env-sh"><a href="#spark-env-sh" class="headerlink" title="spark-env.sh"></a>spark-env.sh</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/default</span><br><span class="line">export HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop</span><br><span class="line">export SPARK_DIST_CLASSPATH=$(hadoop classpath)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里是在配置spark的historyserver</span></span><br><span class="line">export SPARK_HISTORY_OPTS=&quot;-Dspark.history.ui.port=18080</span><br><span class="line">-Dspark.history.retainedApplications=30</span><br><span class="line">-Dspark.history.fs.logDirectory=hdfs://mycluster/spark/eventLog&quot;</span><br><span class="line">export YARN_CONF_DIR=$HADOOP_HOME/etc/hadoop</span><br></pre></td></tr></table></figure>

<h4 id="spark-defaults-conf"><a href="#spark-defaults-conf" class="headerlink" title="spark-defaults.conf"></a>spark-defaults.conf</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这里是在配置spark的historyserver</span></span><br><span class="line">spark.eventLog.enabled           true</span><br><span class="line">spark.eventLog.dir               hdfs://mycluster/spark/eventLog #一定要自己先手动建立这个目录</span><br><span class="line">spark.eventLog.compress          true</span><br><span class="line">spark.yarn.historyServer.address=node01:18080</span><br><span class="line">spark.history.ui.port=18080</span><br></pre></td></tr></table></figure>

<h2 id="配置-VSCode"><a href="#配置-VSCode" class="headerlink" title="配置 VSCode"></a>配置 VSCode</h2><p>官网 rpm安装</p>
<p>Shell中输入 code 启动</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">配置代码提醒</span><br><span class="line">    &quot;python.autoComplete.extraPaths&quot;: [</span><br><span class="line">        &quot;$SPARK_HOME/python&quot;,</span><br><span class="line">        <span class="string">&quot;$SPARK_HOME/python/lib/py4j-0.10.9-src.zip&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    &quot;python.analysis.extraPaths&quot;: [</span><br><span class="line">        &quot;$SPARK_HOME/python&quot;,</span><br><span class="line">        <span class="string">&quot;$SPARK_HOME/python/lib/py4j-0.10.9-src.zip&quot;</span></span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<h2 id="Hadoop-HA部署存在的问题"><a href="#Hadoop-HA部署存在的问题" class="headerlink" title="Hadoop HA部署存在的问题"></a>Hadoop HA部署存在的问题</h2><p>这里把我恶心坏了，真的恶心坏了</p>
<p>一开始是我尝试运行部署好的 Spark 的 demo，算 π 那个</p>
<p>提交以后在 ResourceManager 的 Web界面 显示Failed</p>
<p>后来又跑了下 wordcount Demo</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop jar /usr/local/hadoop-3.2.3/share/hadoop/mapreduce/hadoop-mapreduce-examples-3.2.3.jar wordcount input output</span><br></pre></td></tr></table></figure>

<p>一下子我就蚌埠住了，虽然 ResourceManager 那边显示 SUCCEEDED，但是 JobHistory 服务器不显示记录</p>
<p>遂知可能之前配置 Hadoop HA 的时候就存在问题</p>
<p>想查看 logs 查明原因，结果这里配置的也有问题，Web 界面打不开 logs，只好在 Shell 里面用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn logs -applicationId &lt;application-id&gt;</span><br></pre></td></tr></table></figure>

<p>或者直接将 logs 文件下载下来查看 (默认在/tmp/logs/{userid}/logs-tfile)</p>
<p>然后我发现了几个问题 </p>
<p><strong>提示找不到或无法加载主类 org.apache.hadoop.mapreduce.v2.app.MRAppMaster</strong></p>
<p>输出一下hadoop classpath</p>
<p>将其添加至 mapred-site.xml、yarn-site.xml 中的 yarn.application.classpath 属性中</p>
<p><strong>提示ERROR [main] org.apache.hadoop.mapreduce.v2.app.client.MRClientService: Webapps failed to start. Ignoring for now: java.lang.NullPointerException</strong></p>
<p>原因是 yarn-site.xml 中，在配置了 HA 的情况下</p>
<p>yarn.resourcemanager.webapp.address 属性配置方式不同</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.webapp.address.rm1<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>xxx1:8088<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.webapp.address.rm2<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>xxx2:8088<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p><strong>配置 spark history-server</strong> </p>
<p>在上面的配置文件中我已经写过了，同样是使用前启动进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">SPARK_HOME/sbin/start-history-server.sh</span></span><br></pre></td></tr></table></figure>

<p>这个服务器的作用就是在任务结束后仍然能查看任务相关信息</p>
<p>我是因为无法在 RM 的 Web端打开任务(包括MapReduce任务)的 logs，所以才误打误撞启动了这个…</p>
<p><strong>logs 无法查看的原因</strong></p>
<p>这位更是重量级…</p>
<p>yarn-site.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.log.server.url<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>http://node01:19888/jobhistory/logs/<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>是因为之前的配置的时候没有加 <code>http://</code></p>
]]></content>
      <categories>
        <category>开发</category>
        <category>Spark</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>Hadoop</tag>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop集群本地虚拟机部署 + Hadoop HA部署</title>
    <url>/develop/hadoop/689.html</url>
    <content><![CDATA[<p>记录自己尝试搭建Hadoop集群的一次经历</p>
<a id="more"></a>

<h2 id="无HA"><a href="#无HA" class="headerlink" title="无HA"></a>无HA</h2><h3 id="提前设计集群结构"><a href="#提前设计集群结构" class="headerlink" title="提前设计集群结构"></a>提前设计集群结构</h3><p>看一下虚拟机NAT的网段号（一般就是192.168.xxx.0），然后提前规划你的几个节点的ip地址以及主机名</p>
<table>
<thead>
<tr>
<th>node01</th>
<th>node02</th>
<th>node03</th>
<th>node04</th>
<th>node05</th>
</tr>
</thead>
<tbody><tr>
<td>NameNode</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>SecondaryNameNode</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>ResourceManager</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>NodeManager</td>
<td>NodeManager</td>
<td>NodeManager</td>
<td>NodeManager</td>
<td>NodeManager</td>
</tr>
<tr>
<td>DataNode</td>
<td>DataNode</td>
<td>DataNode</td>
<td>DataNode</td>
<td>DataNode</td>
</tr>
</tbody></table>
<h3 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h3><p>CentOS-7-x86_64-2009</p>
<p>先配置一个node，然后用你的虚拟机的clone功能快速clone出其余几个node</p>
<p>安装的时候，记得按照你的提前计划</p>
<ul>
<li>不要使用DHCP服务器分配地址，你手动设置一个固定的ipv4地址，填写子网掩码，VMWare的网关默认是192.168.xxx.2，然后DNS服务器就写网关就可以了</li>
<li>更改你的主机名</li>
<li>除了root用户，你最好创建一个你使用的用户，给一个管理员权限</li>
</ul>
<h4 id="安装vim、net-tools"><a href="#安装vim、net-tools" class="headerlink" title="安装vim、net-tools"></a>安装vim、net-tools</h4>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum list installed | grep net-tools</span><br></pre></td></tr></table></figure>

<p>检查装了没，这个版本的centos应该是自带了</p>
<p>装 vim 方便之后修改配置文件</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install net-tools</span><br><span class="line">sudo yum install vim</span><br><span class="line"></span><br><span class="line">sudo vim /etc/vimrc</span><br><span class="line">set ts=4(加一行，设置Tab键是四个空格长度,看着舒服)</span><br></pre></td></tr></table></figure>

<h4 id="防火墙设置"><a href="#防火墙设置" class="headerlink" title="防火墙设置"></a>防火墙设置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl stop firewalld.service</span><br><span class="line">sudo systemctl disable firewalld.service</span><br></pre></td></tr></table></figure>

<h4 id="关闭SELinux安全系统"><a href="#关闭SELinux安全系统" class="headerlink" title="关闭SELinux安全系统"></a>关闭SELinux安全系统</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/selinux/config</span><br><span class="line"></span><br><span class="line">修改 SELINUX=disabled</span><br></pre></td></tr></table></figure>

<p>不关之后的节点通信可能有问题</p>
<h4 id="准备java环境，配置hadoop"><a href="#准备java环境，配置hadoop" class="headerlink" title="准备java环境，配置hadoop"></a>准备java环境，配置hadoop</h4><p>JDK下载：<a href="https://www.oracle.com/java/technologies/downloads/">https://www.oracle.com/java/technologies/downloads/</a></p>
<p>Hadoop：<a href="https://hadoop.apache.org/releases.html">https://hadoop.apache.org/releases.html</a></p>
<p>这里我用的是</p>
<p>hadoop-3.2.3 和 jdk-8u321-linux-x64</p>
<h5 id="java"><a href="#java" class="headerlink" title="java"></a>java</h5><p>用rpm方式安装了java环境，好处就是不用配置hadoop配置文件hadoop-env.sh中的jdk路径了，rpm安装好之后与默认路径 JAVA_HOME=/usr/java/default 一致</p>
<p>装之前最好把centos自带的openJDK给卸载了</p>
<p>循环这个过程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line">看一下shell输出的版本</span><br><span class="line">rpm -qa | grep jdk</span><br><span class="line">rpm -e 当前版本</span><br></pre></td></tr></table></figure>

<p>直到 java -version 没有输出</p>
<p>然后安装你准备好的包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh rpm文件名</span><br></pre></td></tr></table></figure>

<h5 id="hadoop"><a href="#hadoop" class="headerlink" title="hadoop"></a>hadoop</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo tar -zxvf hadoop-2.7.1.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure>

<p>这里我装到 /usr/local 下了，你随意</p>
<p>然后把hadoop常用的bash目录配置到PATH里</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/profile.d/hadoop.sh</span><br><span class="line">写两行</span><br><span class="line">export HADOOP_HOME=你的hadoop目录在哪里？</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br><span class="line">立即生效</span><br></pre></td></tr></table></figure>

<p>因为是sudo解压的hadoop目录，你的用户没有权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chown -R 用户名:组名 hadoop目录</span><br></pre></td></tr></table></figure>

<p>最后创建一下hadoop的那个 hadoop.tmp.dir ,默认情况下你的NN、DN和之后的JournalNode都是在这个目录存储文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir /var/hadoop_data</span><br><span class="line">sudo chown -R 用户名:组名 /var/hadoop_data</span><br></pre></td></tr></table></figure>

<p>这里我创建到 /var 下了，你随意</p>
<h4 id="配置hadoop的配置文件"><a href="#配置hadoop的配置文件" class="headerlink" title="配置hadoop的配置文件"></a>配置hadoop的配置文件</h4><p>位置都在 你的hadoop目录/etc/hadoop 下存放</p>
<p>主要就是 </p>
<ul>
<li><p>core-site.xml (主节点信息、持久化和数据文件的主目录)</p>
</li>
<li><p>hdfs-site.xml (HDFS默认的数据存放策略)</p>
</li>
<li><p>mapred-site.xml (MapReduce任务调度策略)</p>
</li>
<li><p>yarn-site.xml (Yarn资源管理角色的信息)</p>
</li>
<li><p>workers (datanode的信息，我的版本是 workers，可能你的版本旧的话就是 slaves ) </p>
</li>
</ul>
<p>这里参照老师上课时的文档，以及Hadoop的官方文档</p>
<p><a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html">https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html</a> (配置文件的基本格式，左边栏有各个Configuration文件的默认参数，建议参考一下，里面每个参数的description写参数的作用写的很清楚)</p>
<p><a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/ClusterSetup.html">https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/ClusterSetup.html</a>  (一些集群操作的参数命令)</p>
<p>最后配置一下workers文件，把你规划好的所有DataNode的名字添加进去</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nodexx</span><br><span class="line">nodexx</span><br><span class="line">nodexx</span><br></pre></td></tr></table></figure>

<p>配置hosts文件，让机器能解析你的主机名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br><span class="line">192.168.xxx.80  node01</span><br><span class="line">192.168.xxx.81  node02</span><br><span class="line">192.168.xxx.82  node03</span><br><span class="line">···</span><br></pre></td></tr></table></figure>

<p>把这个文件里面之前的内容删除再添加</p>
<h3 id="开始克隆"><a href="#开始克隆" class="headerlink" title="开始克隆"></a>开始克隆</h3><p>关闭你配置好的这一台机器，克隆出等同于你规划的node数量的机器，过程比安装新机器快得多</p>
<h4 id="更改对应主机名和IP地址"><a href="#更改对应主机名和IP地址" class="headerlink" title="更改对应主机名和IP地址"></a>更改对应主机名和IP地址</h4><p>克隆完所有机器后，在每台机器上依次执行以下的操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/sysconfig/networ-scripts/ifcfg-ens33</span><br><span class="line">把里面的 IPADDR 字段 改成你的规划的对应IP</span><br><span class="line"></span><br><span class="line">sudo vim /etc/hostname</span><br><span class="line">改一下每台主机的主机名</span><br></pre></td></tr></table></figure>

<h4 id="配置集群的ssh免密"><a href="#配置集群的ssh免密" class="headerlink" title="配置集群的ssh免密"></a>配置集群的ssh免密</h4><p>这里可以用 TELNET 登录，我用的 XShell，可以同时把键盘输入发送给多个 Session</p>
<p>建议用这个功能，特别方便</p>
<p>在所有机器上执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line">一路确认后生成rsa公钥</span><br><span class="line"></span><br><span class="line">给每台机器的公钥都拷贝给所有机器</span><br><span class="line">ssh-copy-id node01</span><br><span class="line">ssh-copy-id node02</span><br><span class="line">ssh-copy-id node03</span><br><span class="line">···</span><br></pre></td></tr></table></figure>

<h4 id="集群时间同步"><a href="#集群时间同步" class="headerlink" title="集群时间同步"></a>集群时间同步</h4><p>课件上老师的方法 (适用于集群可以连接外网)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crontab –e</span><br><span class="line">键入下面的一行代码：</span><br><span class="line">0 1 * * * /usr/sbin/ntpdate us.pool.ntp.org</span><br></pre></td></tr></table></figure>

<p>无法连接外网：</p>
<p>我找了一篇博客：<a href="https://blog.csdn.net/a18850765326/article/details/121693857">https://blog.csdn.net/a18850765326/article/details/121693857</a></p>
<p>方法就是选择一个服务器作为同步对象，让其他服务器和他同步</p>
<h4 id="格式化NameNode"><a href="#格式化NameNode" class="headerlink" title="格式化NameNode"></a>格式化NameNode</h4><p>在你的设计的 NameNode 上执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs namenode -format</span><br></pre></td></tr></table></figure>

<p>至此，无HA的Hadoop集群就可以正常运行了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start-dfs.sh</span><br></pre></td></tr></table></figure>



<h2 id="HA部署"><a href="#HA部署" class="headerlink" title="HA部署"></a>HA部署</h2><p>HA部署在官网有两种方式，一种是 QJM，另一种是 NFS</p>
<ul>
<li>使用QJM时，active的NameNode和standby的NameNode使用独立守护进程JournalNode通信。当Active节点执行任何命名空间修改时，它会将修改记录持久地记录到这些 JN 中的大多数。这样Standby 节点就能够从 JN 中读取同步数据</li>
<li>NFS与QJM类似，只不过没有使用JournalNode，使用了一个支持NFS的远程文件管理器装载在每个NameNode上同步数据</li>
</ul>
<p>我使用了QJM方式</p>
<h3 id="集群结构设计"><a href="#集群结构设计" class="headerlink" title="集群结构设计"></a>集群结构设计</h3><table>
<thead>
<tr>
<th>node01</th>
<th>node02</th>
<th>node03</th>
<th>node04</th>
<th>node05</th>
</tr>
</thead>
<tbody><tr>
<td>NameNode</td>
<td></td>
<td><strong>NameNode</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>ZKFailoverController</strong></td>
<td></td>
<td><strong>ZKFailoverController</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>ResourceManager</td>
<td></td>
<td></td>
<td><strong>ResourceManager</strong></td>
</tr>
<tr>
<td></td>
<td><strong>JournalNode</strong></td>
<td></td>
<td><strong>JournalNode</strong></td>
<td><strong>JournalNode</strong></td>
</tr>
<tr>
<td>NodeManager</td>
<td>NodeManager</td>
<td>NodeManager</td>
<td>NodeManager</td>
<td>NodeManager</td>
</tr>
<tr>
<td>DataNode</td>
<td>DataNode</td>
<td>DataNode</td>
<td>DataNode</td>
<td>DataNode</td>
</tr>
<tr>
<td><strong>QuorumPeerMain</strong></td>
<td><strong>QuorumPeerMain</strong></td>
<td><strong>QuorumPeerMain</strong></td>
<td><strong>QuorumPeerMain</strong></td>
<td><strong>QuorumPeerMain</strong></td>
</tr>
</tbody></table>
<p>对应的进程的含义如果你觉得好奇，官网写的很清楚</p>
<p><strong>JournalNode</strong>、<strong>ZKFailoverController</strong>：<a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HDFSHighAvailabilityWithQJM.html">https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HDFSHighAvailabilityWithQJM.html</a></p>
<p>我是先部署了无HA集群，再进行修改成HA集群，如果你要部署HA，可以在克隆前就把Hadoop的配置文件写成HA的配置，并且把Zookeeper配置好</p>
<h3 id="安装Zookeeper"><a href="#安装Zookeeper" class="headerlink" title="安装Zookeeper"></a>安装Zookeeper</h3><p>官网：<a href="https://zookeeper.apache.org/releases.html">https://zookeeper.apache.org/releases.html</a></p>
<p>我用了 latest stable release 版本，apache-zookeeper-3.7.0</p>
<h4 id="先在一台机器上部署"><a href="#先在一台机器上部署" class="headerlink" title="先在一台机器上部署"></a>先在一台机器上部署</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-zookeeper-3.7.0-bin.tar.gz -C /usr/local/</span><br><span class="line">sudo chown -R 用户名:组名 /usr/local/apache-zookeeper-3.7.0-bin</span><br></pre></td></tr></table></figure>

<p>同样位置不固定</p>
<p>修改配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd apache-zookeeper-3.7.0-bin/conf/</span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br><span class="line">vim zoo.cfg</span><br><span class="line"></span><br><span class="line">修改dataDir=/var/zookeeper_data/ 位置不固定</span><br><span class="line"></span><br><span class="line">添加：</span><br><span class="line">server.1=node01:2888:3888</span><br><span class="line">server.2=node02:2888:3888</span><br><span class="line">server.3=node03:2888:3888</span><br><span class="line">···</span><br><span class="line">之后就:wq</span><br><span class="line"></span><br><span class="line">创建dataDir文件夹</span><br><span class="line">sudo mkdir /var/zookeeper_data</span><br><span class="line">sudo chown -R 用户名:组名 /var/zookeeper_data</span><br><span class="line">echo 1 &gt; /var/zookeeper_data/myid</span><br></pre></td></tr></table></figure>

<h4 id="再SCP发送到其他节点上"><a href="#再SCP发送到其他节点上" class="headerlink" title="再SCP发送到其他节点上"></a>再SCP发送到其他节点上</h4><p>这里说的是先部署了非HA集群，克隆时没有克隆zookeeper的情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo scp -r /usr/local/apache-zookeeper-3.7.0-bin node02:/usr/local</span><br><span class="line">sudo scp -r /var/zookeeper_data node02:/var</span><br><span class="line">···</span><br><span class="line">记得把权限提升</span><br><span class="line">然后把每个myid文件都改成对应的id</span><br><span class="line">例如：node02改成2</span><br></pre></td></tr></table></figure>



<h3 id="修改Hadoop的配置文件为HA"><a href="#修改Hadoop的配置文件为HA" class="headerlink" title="修改Hadoop的配置文件为HA"></a>修改Hadoop的配置文件为HA</h3><p>同样是这些文件</p>
<ul>
<li>core-site.xml (主节点信息、持久化和数据文件的主目录)</li>
<li>hdfs-site.xml (HDFS默认的数据存放策略)</li>
<li>mapred-site.xml (MapReduce任务调度策略)</li>
<li>yarn-site.xml (Yarn资源管理角色的信息)</li>
</ul>
<p>同样参照老师上课时的文档，以及Hadoop的官方文档</p>
<p><a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HDFSHighAvailabilityWithQJM.html">https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HDFSHighAvailabilityWithQJM.html</a></p>
<h3 id="如何启动"><a href="#如何启动" class="headerlink" title="如何启动"></a>如何启动</h3><h4 id="启动Zookeeper"><a href="#启动Zookeeper" class="headerlink" title="启动Zookeeper"></a>启动Zookeeper</h4><p>所有节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Zookeeper目录/bin/zkServer.sh start</span><br></pre></td></tr></table></figure>

<h4 id="手动启动JournalNode（仅第一次在所有规划好的JournalNode上启动）"><a href="#手动启动JournalNode（仅第一次在所有规划好的JournalNode上启动）" class="headerlink" title="手动启动JournalNode（仅第一次在所有规划好的JournalNode上启动）"></a>手动启动JournalNode（仅第一次在所有规划好的JournalNode上启动）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs --daemon start journalnode</span><br></pre></td></tr></table></figure>

<h4 id="格式化启动同步namenode（仅第一次）"><a href="#格式化启动同步namenode（仅第一次）" class="headerlink" title="格式化启动同步namenode（仅第一次）"></a>格式化启动同步namenode（仅第一次）</h4><p>在一个NameNode上执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs namenode -format</span><br><span class="line">hdfs --daemon start namenode</span><br></pre></td></tr></table></figure>

<p>这时候在另一个节点上执行同步</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs namenode -bootstrapStandby</span><br></pre></td></tr></table></figure>

<h4 id="格式化ZKFC（仅第一次）"><a href="#格式化ZKFC（仅第一次）" class="headerlink" title="格式化ZKFC（仅第一次）"></a>格式化ZKFC（仅第一次）</h4><p>在任意一个NameNode上格式化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs zkfc -formatZK</span><br></pre></td></tr></table></figure>

<h4 id="之后就可以启动了"><a href="#之后就可以启动了" class="headerlink" title="之后就可以启动了"></a>之后就可以启动了</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start-all.sh</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>配置文件别敲错</li>
<li><strong>启动不了进程去hadoop/logs里面查看对应进程的log文件中的error查错</strong></li>
<li>使用虚拟机快照记录当前状态，之后可以回档</li>
</ol>
]]></content>
      <categories>
        <category>开发</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT-Missing-Semester-01</title>
    <url>/knowledge/MIT-Missing-Semester/687.html</url>
    <content><![CDATA[<h2 id="Topic-1-Shell"><a href="#Topic-1-Shell" class="headerlink" title="Topic 1 Shell"></a>Topic 1 Shell</h2><a id="more"></a>

<h3 id="Points"><a href="#Points" class="headerlink" title="Points"></a>Points</h3><ol>
<li>date</li>
<li>echo</li>
<li>escape</li>
<li>echo $PATH</li>
<li>which</li>
<li>pwd</li>
<li>cd</li>
<li>dot, dot dot</li>
<li>ls</li>
<li>/ </li>
<li>- dash: cd -, program -h –help</li>
<li>permission bits rwx user group others</li>
<li>mv</li>
<li>cp</li>
<li>mkdir rmdir</li>
<li>quota “ “</li>
<li>man: manual page</li>
<li>two streams &gt;, &lt;, &gt;&gt;, &lt;&lt;</li>
<li>tail -n1</li>
<li>pipe |</li>
<li>sudo echo 1 &gt; /sys/**   right ?  Permission denied ?</li>
<li>sudo su</li>
<li>echo 1 | sudo tee /sys/**</li>
<li>find</li>
</ol>
<h3 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li><p>For this course, you need to be using a Unix shell like Bash or ZSH. If you are on Linux or macOS, you don’t have to do anything special. If you are on Windows, you need to make sure you are not running cmd.exe or PowerShell; you can use <a href="https://docs.microsoft.com/en-us/windows/wsl/">Windows Subsystem for Linux</a> or a Linux virtual machine to use Unix-style command-line tools. To make sure you’re running an appropriate shell, you can try the command <code>echo $SHELL</code>. If it says something like <code>/bin/bash</code> or <code>/usr/bin/zsh</code>, that means you’re running the right program.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hadoop@wool-virtual-machine:~$ echo $SHELL</span><br><span class="line">&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>Create a new directory called <code>missing</code> under <code>/tmp</code>.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop@wool-virtual-machine:~$ cd /tmp</span><br><span class="line">hadoop@wool-virtual-machine:/tmp$ mkdir missing</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>Look up the <code>touch</code> program. The <code>man</code> program is your friend.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">man touch</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>Use <code>touch</code> to create a new file called <code>semester</code> in <code>missing</code>.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop@wool-virtual-machine:/tmp$ touch missing/semester</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li><p>Write the following into that file, one line at a time:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">curl --head --silent https://missing.csail.mit.edu</span><br></pre></td></tr></table></figure>

<p>The first line might be tricky to get working. It’s helpful to know that <code>#</code> starts a comment in Bash, and <code>!</code> has a special meaning even within double-quoted (<code>&quot;</code>) strings. Bash treats single-quoted strings (<code>&#39;</code>) differently: they will do the trick in this case. See the Bash <a href="https://www.gnu.org/software/bash/manual/html_node/Quoting.html">quoting</a> manual page for more information.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop@wool-virtual-machine:/tmp$ cd missing</span><br><span class="line">hadoop@wool-virtual-machine:/tmp/missing$ echo \#\!/bin/bash &gt; semester</span><br><span class="line">hadoop@wool-virtual-machine:/tmp/missing$ echo curl --head --silent https://missing.csail.mit.edu &gt;&gt; semester</span><br><span class="line">hadoop@wool-virtual-machine:/tmp/missing$ cat semester </span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">curl --head --silent https://missing.csail.mit.edu</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="6">
<li><p>Try to execute the file, i.e. type the path to the script (<code>./semester</code>) into your shell and press enter. Understand why it doesn’t work by consulting the output of <code>ls</code> (hint: look at the permission bits of the file).</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop@wool-virtual-machine:/tmp/missing$ ./semester</span><br><span class="line">bash: ./semester: permission denied</span><br><span class="line">hadoop@wool-virtual-machine:/tmp/missing$ ls -l semester </span><br><span class="line">-rw-rw-r-- 1 hadoop hadoop 63 3月  29 21:11 semester</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="7">
<li><p>Run the command by explicitly starting the <code>sh</code> interpreter, and giving it the file <code>semester</code> as the first argument, i.e. <code>sh semester</code>. Why does this work, while <code>./semester</code> didn’t?</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop@wool-virtual-machine:/tmp/missing$ sh semester</span><br><span class="line">HTTP/2 200 </span><br><span class="line">server: GitHub.com</span><br><span class="line">content-type: text/html; charset=utf-8</span><br><span class="line">last-modified: Fri, 04 Mar 2022 17:03:44 GMT</span><br><span class="line">access-control-allow-origin: *</span><br><span class="line">etag: &quot;62224670-1f37&quot;</span><br><span class="line">expires: Mon, 28 Mar 2022 08:24:18 GMT</span><br><span class="line">cache-control: max-age=600</span><br><span class="line">x-proxy-cache: MISS</span><br><span class="line">x-github-request-id: C87C:7EE2:1B48AE:1F3E2D:62416E5A</span><br><span class="line">accept-ranges: bytes</span><br><span class="line">date: Tue, 29 Mar 2022 13:19:08 GMT</span><br><span class="line">via: 1.1 varnish</span><br><span class="line">age: 0</span><br><span class="line">x-served-by: cache-hnd18742-HND</span><br><span class="line">x-cache: HIT</span><br><span class="line">x-cache-hits: 1</span><br><span class="line">x-timer: S1648559948.926671,VS0,VE390</span><br><span class="line">vary: Accept-Encoding</span><br><span class="line">x-fastly-request-id: 64c590c0fcb701c17b33cd011d2e48c65d877970</span><br><span class="line">content-length: 7991</span><br></pre></td></tr></table></figure>

<p><strong>Reason: the permission bits of the semester indicates that everyone could read it and sh just reads the semester</strong></p>
</li>
</ol>
<ol start="8">
<li><p>Look up the <code>chmod</code> program (e.g. use <code>man chmod</code>).</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NAME</span><br><span class="line">       chmod - change file mode bits</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       chmod [OPTION]... MODE[,MODE]... FILE...</span><br><span class="line">       chmod [OPTION]... OCTAL-MODE FILE...</span><br><span class="line">       chmod [OPTION]... --reference=RFILE FILE...</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="9">
<li><p>Use <code>chmod</code> to make it possible to run the command <code>./semester</code> rather than having to type <code>sh semester</code>. How does your shell know that the file is supposed to be interpreted using <code>sh</code>? See this page on the <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a> line for more information.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop@wool-virtual-machine:/tmp/missing$ chmod a+x semester</span><br><span class="line">hadoop@wool-virtual-machine:/tmp/missing$ ls -l</span><br><span class="line">total 4</span><br><span class="line">-rwxrwxr-x 1 hadoop hadoop 63 3月  29 21:11 semester</span><br><span class="line"></span><br><span class="line">hadoop@wool-virtual-machine:/tmp/missing$ ./semester </span><br><span class="line">HTTP/2 200 </span><br><span class="line">server: GitHub.com</span><br><span class="line">........</span><br></pre></td></tr></table></figure>

<p>Wiki: In computing, a shebang is the character sequence consisting of the characters number sign and exclamation mark (#!) at the beginning of a script. It is also called sha-bang, hashbang, pound-bang, or hash-pling.</p>
<p>When a text file with a shebang is used as if it is an executable in a Unix-like operating system, the program loader mechanism parses the rest of the file’s initial line as an interpreter directive.</p>
</li>
</ol>
<ol start="10">
<li><p>Use <code>|</code> and <code>&gt;</code> to write the “last modified” date output by <code>semester</code> into a file called <code>last-modified.txt</code> in your home directory.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop@wool-virtual-machine:/tmp/missing$ ls -l semester | cut --delimiter=&#x27; &#x27; -f6,7,8,9 | sudo tee ~/last-modified.txt </span><br><span class="line">3月  29 21:47</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="11">
<li><p>Write a command that reads out your laptop battery’s power level or your desktop machine’s CPU temperature from <code>/sys</code>. Note: if you’re a macOS user, your OS doesn’t have sysfs, so you can skip this exercise.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i can&#39;t find them.</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>知识</category>
        <category>MIT-Missing-Semester</category>
      </categories>
      <tags>
        <tag>知识</tag>
        <tag>MIT-Missing-Semester</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity3D学习记录 21.9.12</title>
    <url>/develop/unity/685.html</url>
    <content><![CDATA[<p>整整两周的 Unity 学习告一段落，但是真的结束了吗？</p>
<a id="more"></a>

<p>之前的第三人称游戏我使用了 <code>c#</code> 动态控制 <code>timeline</code> 中的 <code>track</code> 的 <code>binding</code> 的方法，确实有点复杂，后来学习到 Unity 原来有 <code>Animation</code> 系统，于是乎花了四到五天制作并完善了一个简单的射击游戏，并没有将其设计成联机游戏（下次一定），制作这个游戏技术力可能不是很高，但是这个过程还是让我体会到了之前并没有体会过的感觉，也想通了一些很简单的东西，很值得</p>
<h3 id="B站视频：https-www-bilibili-com-video-BV1nb4y127Gh"><a href="#B站视频：https-www-bilibili-com-video-BV1nb4y127Gh" class="headerlink" title="B站视频：https://www.bilibili.com/video/BV1nb4y127Gh"></a>B站视频：<a href="https://www.bilibili.com/video/BV1nb4y127Gh">https://www.bilibili.com/video/BV1nb4y127Gh</a></h3><h3 id="下载：https-pan-baidu-com-s-1R1vc75IugK6cWULWBluAqg"><a href="#下载：https-pan-baidu-com-s-1R1vc75IugK6cWULWBluAqg" class="headerlink" title="下载：https://pan.baidu.com/s/1R1vc75IugK6cWULWBluAqg"></a>下载：<a href="https://pan.baidu.com/s/1R1vc75IugK6cWULWBluAqg">https://pan.baidu.com/s/1R1vc75IugK6cWULWBluAqg</a></h3><p><strong>提取码：1573</strong></p>
]]></content>
      <categories>
        <category>开发</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>自我迭代</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity3D学习记录 21.9.6</title>
    <url>/develop/unity/679.html</url>
    <content><![CDATA[<p>9.2号到现在逐步学习了一些关于 Unity 引擎 c# 的相关的一些 api，以及 TimeLine 和 Cinemachine 相关插件的使用</p>
<a id="more"></a>

<p>在遇到实例化 Playable 对象后重新绑定 TimeLine 中 track 的问题，一开始并没有养成搜索相关官方 api 文档的习惯，在网络上寻找解决方案，但是遇到了一些问题（切换 track 后 Playable 绑定的图形没有刷新），询问老师后老师给我提供了重新建立图形的方法，<code>PlayableDirector.RebuildGraph()</code> 这个方法，我再次查阅官方手册后寻找到了另一个解决方案 <code>PlayableDirector.RebindPlayableGraphOutputs()</code></p>
<p>通过 TimeLine 和 unity store 里面的一个免费的人物 prefab，我制作出了一款简单的第三人称的小游戏，高中的一些基本的知识还是有用的，椭圆函数能解决两个轴速叠加超过上限的问题…</p>
<h3 id="下载：https-pan-baidu-com-s-16-DakcQ6aINkeU2wBBOTSw"><a href="#下载：https-pan-baidu-com-s-16-DakcQ6aINkeU2wBBOTSw" class="headerlink" title="下载：https://pan.baidu.com/s/16-DakcQ6aINkeU2wBBOTSw"></a>下载：<a href="https://pan.baidu.com/s/16-DakcQ6aINkeU2wBBOTSw">https://pan.baidu.com/s/16-DakcQ6aINkeU2wBBOTSw</a></h3><p><strong>提取码：0902</strong></p>
<p>后面更新一个第一人称 fps 试试 （也许支持多人联机）</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>自我迭代</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity3D学习记录 21.9.2</title>
    <url>/develop/unity/677.html</url>
    <content><![CDATA[<p>参加了这次Unity学习活动</p>
<p>这两天学习了一些引擎相关的知识，着手开始编写逻辑</p>
<p>今晚做了个吃金币的小游戏，属实是做的第一个小游戏了，蕾姆</p>
<p>快开学了，大三了</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>自我迭代</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习记录 21.07.15</title>
    <url>/develop/Java/JavaSE/675.html</url>
    <content><![CDATA[<p>21年暑假小学期 —— 摸鱼中学习</p>
<p>了解了类加载器、反射、注解相关知识</p>
<p>了解了一些Java底层的相关数据结构 Set、Map（Treexxx &amp; Hashxxx），红黑树的一些相关知识</p>
<p>准备开始了解Spring框架以及Vue的相关知识</p>
<p>怎么说呢，反正不太好说，但也不一定</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>Java</tag>
        <tag>自我迭代</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/algorithm/search/673.html</url>
    <content><![CDATA[<p>红黑树 —— 红黑规则及添加节点的规则</p>
<a id="more"></a>

<h2 id="红黑规则"><a href="#红黑规则" class="headerlink" title="红黑规则"></a>红黑规则</h2><ul>
<li>每一个节点都是红色或黑色的</li>
<li>根节点是黑色的</li>
<li>如果一个节点没有子节点或者父节点，则该节点相应的指针属性值为Nil，这些Nil视为叶节点，每一个叶节点（Nil）是黑色的</li>
<li>不能出现两个红色节点相连（如果节点是红色的，则他的子结点必须是黑色的）</li>
<li>对于每一个节点，到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点</li>
</ul>
<h2 id="节点的添加规则"><a href="#节点的添加规则" class="headerlink" title="节点的添加规则"></a>节点的添加规则</h2><p>添加节点时，默认添加的节点为红色（添加红色效率高）</p>
<p>添加节点的规则：</p>
<ol>
<li><p>根节点位置：直接变为黑色</p>
</li>
<li><p>非根节点位置</p>
<ol>
<li><p>父节点为黑色：不需要操作</p>
</li>
<li><p>父节点为红色</p>
<ol>
<li><p>叔叔节点为红色：</p>
<p>将父节点、叔叔节点设为黑色，将祖父节点设为红色，如果祖父节点为根节点，则将根节点再次变为黑色</p>
</li>
<li><p>叔叔节点为黑色：</p>
<p>将父节点设为黑色，祖父节点设为红色，以祖父节点为支点进行旋转（左高右旋，右高左旋）</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
        <category>查找</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title>DP问题分析方法</title>
    <url>/algorithm/dp/671.html</url>
    <content><![CDATA[<p>DP问题分析 —— yxc 的 DP问题分析方法</p>
<a id="more"></a>

<p>DP 的两个角度 <strong>状态表示</strong> 及 <strong>状态计算（状态转移方程）</strong></p>
<p><strong>化零为整：</strong>将具有共性的方案划归到一个集合中表示</p>
<p><strong>化整为零：</strong>将集合进行划分成若干子集来分别求解</p>
<h2 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h2><p>很难根据题目现推，经验之谈居多</p>
<p>状态表示主要是两个角度 分别为 <strong>集合</strong> 和 <strong>属性</strong></p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>根据题目来确定用几维空间来储存状态的集合，集合一般为满足多重条件下的方案的集合</p>
<p>选择问题（背包问题等）一般具有以下特性：</p>
<ul>
<li>第一维的 <code>i</code> 是只考虑前 <code>i</code> 个物品 </li>
<li>剩下的维数为题目的几个限制，例如重量、数量、体积等</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性一般是给集合表示的方案进行值的定性，一般为 最大值、最小值、数量 等</p>
<h2 id="状态计算"><a href="#状态计算" class="headerlink" title="状态计算"></a>状态计算</h2><p>状态计算一般为对集合进行一个划分，划分为若干个子集</p>
<p>一般是通过方案最后的一个不同点来进行划分</p>
<p>（例如 01背包问题 中通过选或者不选择第 <code>i</code> 个物品将集合划分为两个子集）</p>
<p>划分出的子集有两个原则 <strong>不重复</strong> 与 <strong>不遗漏</strong></p>
<h2 id="常见的模型"><a href="#常见的模型" class="headerlink" title="常见的模型"></a>常见的模型</h2><h3 id="组合模型"><a href="#组合模型" class="headerlink" title="组合模型"></a>组合模型</h3><p>假设有一堆物品，在满足某种限制的条件下挑一些物品出来（部分选择合法），求所有组合中最好的情况</p>
<p>常见背包问题</p>
<h3 id="路线模型"><a href="#路线模型" class="headerlink" title="路线模型"></a>路线模型</h3><h3 id="线性模型-最大上升子序列"><a href="#线性模型-最大上升子序列" class="headerlink" title="线性模型 最大上升子序列"></a>线性模型 最大上升子序列</h3>]]></content>
      <categories>
        <category>算法</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb学习记录</title>
    <url>/develop/Java/JavaWeb/670.html</url>
    <content><![CDATA[<p>寒假学习一下JavaWeb相关知识</p>
<p>做一个记录吧，之后会写个小东西支棱起来</p>
<h3 id="2021-4-9-更新"><a href="#2021-4-9-更新" class="headerlink" title="2021.4.9 更新"></a>2021.4.9 更新</h3><p><del>至今未开始</del></p>
<h3 id="2021-9-2-更新"><a href="#2021-9-2-更新" class="headerlink" title="2021.9.2 更新"></a>2021.9.2 更新</h3><p>emm，小学期的作业总该是个小东西了吧，做了两个月了，用JavaWeb开发知识结合 Vue + ElementUI 搭建了一个简单的商品管理系统，过段时间贴上来</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
        <tag>自我迭代</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 62. 不同路径 记忆化搜索 动态规划</title>
    <url>/leetcode/665.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/unique-paths/">https://leetcode-cn.com/problems/unique-paths/</a></p>
<a id="more"></a>

<h2 id="LeetCode-62-不同路径-记忆化搜索-动态规划"><a href="#LeetCode-62-不同路径-记忆化搜索-动态规划" class="headerlink" title="LeetCode 62. 不同路径 记忆化搜索 动态规划"></a>LeetCode 62. 不同路径 记忆化搜索 动态规划</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：m &#x3D; 3, n &#x3D; 7</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：m &#x3D; 3, n &#x3D; 2</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：m &#x3D; 7, n &#x3D; 3</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure>

<p>示例 4：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：m &#x3D; 3, n &#x3D; 3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
<li>题目数据保证答案小于等于 <code>2e9</code></li>
</ul>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> num[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> nowm, <span class="keyword">int</span> nown)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nowm == m &amp;&amp; nown == n)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(num[nowm][nown])</span><br><span class="line">            <span class="keyword">return</span> num[nowm][nown];</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nowm + <span class="number">1</span> &lt;= m)</span><br><span class="line">            sum += dfs(m, n, nowm + <span class="number">1</span>, nown);</span><br><span class="line">        <span class="keyword">if</span>(nown + <span class="number">1</span> &lt;= n)</span><br><span class="line">            sum += dfs(m, n, nowm, nown + <span class="number">1</span>);</span><br><span class="line">        num[nowm][nown] = sum;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        ans = dfs(m, n, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">f</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)</span><br><span class="line">            f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">            f[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j] + f[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>LeetCode</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 842. 将数组拆分成斐波那契序列 回溯 + 剪枝</title>
    <url>/leetcode/663.html</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/">https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/</a></p>
<a id="more"></a>

<h2 id="LeetCode-842-将数组拆分成斐波那契序列-回溯-剪枝"><a href="#LeetCode-842-将数组拆分成斐波那契序列-回溯-剪枝" class="headerlink" title="LeetCode 842. 将数组拆分成斐波那契序列 回溯 + 剪枝"></a>LeetCode 842. 将数组拆分成斐波那契序列 回溯 + 剪枝</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>给定一个数字字符串 <code>S</code>，比如 <code>S = &quot;123456579&quot;</code>，我们可以将它分成斐波那契式的序列 <code>[123, 456, 579]</code>。</p>
<p>形式上，斐波那契式序列是一个非负整数列表 <code>F</code>，且满足：</p>
<ul>
<li><code>0 &lt;= F[i] &lt;= 2^31 - 1</code>，（也就是说，每个整数都符合 32 位有符号整数类型）；</li>
<li><code>F.length &gt;= 3</code>；</li>
<li>对于所有的<code>0 &lt;= i &lt; F.length - 2</code>，都有 <code>F[i] + F[i+1] = F[i+2]</code> 成立。<br>另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。</li>
</ul>
<p>返回从 <code>S</code> 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 <code>[]</code>。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;123456579&quot;</span><br><span class="line">输出：[123,456,579]</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;11235813&quot;</span><br><span class="line">输出: [1,1,2,3,5,8,13]</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;112358130&quot;</span><br><span class="line">输出: []</span><br><span class="line">解释: 这项任务无法完成。</span><br></pre></td></tr></table></figure>

<p>示例 4：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;0123&quot;</span><br><span class="line">输出：[]</span><br><span class="line">解释：每个块的数字不能以零开头，因此 &quot;01&quot;，&quot;2&quot;，&quot;3&quot; 不是有效答案。</span><br></pre></td></tr></table></figure>

<p>示例 5：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;1101111&quot;</span><br><span class="line">输出: [110, 1, 111]</span><br><span class="line">解释: 输出 [11,0,11,11] 也同样被接受。</span><br></pre></td></tr></table></figure>


<p>提示：</p>
<ol>
<li><code>1 &lt;= S.length &lt;= 200</code></li>
<li>字符串 <code>S</code> 中只含有数字。</li>
</ol>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ans, <span class="built_in">string</span> S, <span class="keyword">int</span> index, <span class="keyword">long</span> <span class="keyword">long</span> sum, <span class="keyword">int</span> prev)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == S.length())</span><br><span class="line">            <span class="keyword">return</span> (ans.size() &gt;= <span class="number">3</span>); <span class="comment">// 数组中有三个或三个以上元素则满足条件</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> cur = <span class="number">0</span>; <span class="comment">// 当前切割数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index;i &lt; S.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur * <span class="number">10</span> + S[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; index &amp;&amp; S[index] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//当前切割数 长度大于一 且为 0 开头 剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(cur &gt; INT_MAX)</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//不符合 32位 有符号整数类型 剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(ans.size() &gt;= <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(cur &gt; sum)</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 大于则剪枝</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(cur &lt; sum)</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// 小于继续增加当前分割数位数</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(cur); <span class="comment">// 两种情况 数组中元素小于2 或 当前分割数等于前两个数字和</span></span><br><span class="line">            <span class="keyword">if</span>(backTrack(ans, S, i + <span class="number">1</span>, cur + prev, cur)) <span class="comment">// 递归满足条件返回 true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            ans.pop_back(); <span class="comment">// 不满足条件则回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">splitIntoFibonacci</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        backTrack(ans, S, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>记得把板子背会！</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉排序树</title>
    <url>/algorithm/search/659.html</url>
    <content><![CDATA[<p>二叉排序树 —— 具有特殊性质的二叉树</p>
<a id="more"></a>

<p><strong>数据结构课代码实现 之 二叉排序树</strong></p>
<h2 id="简要理解"><a href="#简要理解" class="headerlink" title="简要理解"></a>简要理解</h2><p>二叉排序树具有如下性质：</p>
<ol>
<li>二叉排序树可为空</li>
<li>如果二叉排序树不为空树，则排序树上每个结点都满足：<ol>
<li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值</li>
<li>若右子树不空，则右子树上所有结点的值均大于它的根结点的值</li>
<li>该结点的左、右子树也分别为一棵二叉排序树</li>
</ol>
</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><strong>插入过程：</strong></p>
<ol>
<li>初始为空树，直接插入根节点</li>
<li>不为空树时，进行查找操作<ol>
<li>如果在树中找到插入的数据，则不需要插入</li>
<li>如果找不到，查找函数会返回需要插入结点的父节点 (查找操作中会记录父结点，方便插入操作)</li>
</ol>
</li>
</ol>
<p><strong>删除过程：</strong></p>
<p>需要注意一下，删除一个结点分为两种情况：</p>
<ol>
<li>该结点只有左右子树，则将该结点的左 (右) 子树的根结点代替此结点即可，不会破坏二叉排序树性质</li>
<li>该结点既有左子树又有右子树，则需要利用二叉排序树的性质（中序输出这棵二叉树即为一个由小到大的序列），所以删除该结点，相当于用删除结点的 前驱 或者 后继结点 的 <code>data</code>值 来代替删除结点的 <code>data</code>值，然后删除 前驱 或者 后继结点，以下代码是用前驱结点来代替</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span>* <span class="title">lc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span>* <span class="title">rc</span>;</span> </span><br><span class="line">&#125;BiNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EQ</span><span class="params">(<span class="keyword">int</span> key1, <span class="keyword">int</span> key2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key1 == key2)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LT</span><span class="params">(<span class="keyword">int</span> key1, <span class="keyword">int</span> key2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key1 &lt; key2)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SearchBST</span><span class="params">(BiTree T, <span class="keyword">int</span> key, BiTree f, BiTree &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T)</span><br><span class="line">    &#123;</span><br><span class="line">        p = f;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(EQ(key, T-&gt;data))</span><br><span class="line">    &#123;</span><br><span class="line">        p = T;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(LT(key, T-&gt;data))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;lc, key, T, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;rc, key, T, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertBST</span><span class="params">(BiTree &amp;T, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiTree p;</span><br><span class="line">    <span class="keyword">if</span>(!SearchBST(T, key, <span class="literal">NULL</span>, p))</span><br><span class="line">    &#123;</span><br><span class="line">        BiTree s = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiNode));</span><br><span class="line">        s-&gt;data = key;</span><br><span class="line">        s-&gt;lc = <span class="literal">NULL</span>;</span><br><span class="line">        s-&gt;rc = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p) T = s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(LT(key, p-&gt;data))</span><br><span class="line">            p-&gt;lc = s;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p-&gt;rc = s;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete</span><span class="params">(BiTree &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiTree q;</span><br><span class="line">    <span class="keyword">if</span>(!p-&gt;rc)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;lc;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!p-&gt;lc)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;rc;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        BiTree s = p-&gt;lc; <span class="comment">// 左移至删除结点的左儿子</span></span><br><span class="line">        <span class="keyword">while</span>(s-&gt;rc) <span class="comment">// 左儿子有右子树的情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            q = s; <span class="comment">// q记录前驱结点的前一个结点</span></span><br><span class="line">            s = s-&gt;rc; <span class="comment">// s记录前驱结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;data = s-&gt;data; <span class="comment">// 用前驱结点的 data 代替 删除结点的 data</span></span><br><span class="line">        <span class="keyword">if</span>(q != p) <span class="comment">// q != p 的情况即是删除结点的左儿子有右子树</span></span><br><span class="line">            q-&gt;rc = s-&gt;lc; <span class="comment">// 将前驱结点的左子树接到前一个结点的右子树上</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            q-&gt;lc = s-&gt;lc; <span class="comment">// 删除结点的左儿子无右子树 左儿子就是前驱结点 将其左子树接到被删除结点的左子树上</span></span><br><span class="line">        <span class="built_in">free</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteBST</span><span class="params">(BiTree &amp;T, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(EQ(key, T-&gt;data)) <span class="keyword">return</span> Delete(T);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(LT(key, T-&gt;data)) <span class="keyword">return</span> DeleteBST(T-&gt;lc, key);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> DeleteBST(T-&gt;rc, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnOrder</span><span class="params">(BiTree T, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> cen, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        OnOrder(T-&gt;lc, <span class="number">1</span>, <span class="number">0</span>, cen + <span class="number">1</span>, T-&gt;data); </span><br><span class="line">        <span class="keyword">if</span>(fa == <span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;根节点&quot;</span> &lt;&lt; <span class="string">&quot; 该点为：&quot;</span> &lt;&lt; T-&gt;data &lt;&lt; <span class="string">&quot; 层数为：&quot;</span> &lt;&lt; cen &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;该点为：&quot;</span> &lt;&lt; T-&gt;data &lt;&lt; <span class="string">&quot; 该节点为 &quot;</span> &lt;&lt; fa &lt;&lt; <span class="string">&quot; 的左儿子&quot;</span> &lt;&lt; <span class="string">&quot; 层数为：&quot;</span> &lt;&lt; cen &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(r)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;该点为：&quot;</span> &lt;&lt; T-&gt;data &lt;&lt; <span class="string">&quot; 该节点为 &quot;</span> &lt;&lt; fa &lt;&lt; <span class="string">&quot; 的右儿子&quot;</span> &lt;&lt; <span class="string">&quot; 层数为：&quot;</span> &lt;&lt; cen &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        OnOrder(T-&gt;rc, <span class="number">0</span>, <span class="number">1</span>, cen + <span class="number">1</span>, T-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiTree T;</span><br><span class="line">    T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入要插入的结点数：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;依次输入每个结点的data, 空格分开&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        InsertBST(T, x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    BiTree p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入查找的data：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="keyword">if</span>(SearchBST(T, x, <span class="literal">NULL</span>, p))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找见了&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没找见&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入删除的点：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="keyword">if</span>(DeleteBST(T, x))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;删除了&quot;</span> &lt;&lt; x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;怎么删除啊？&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;这是这棵树：&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    OnOrder(T, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>查找</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title>图的拓扑排序与关键路径</title>
    <url>/algorithm/graph-theory/655.html</url>
    <content><![CDATA[<p>拓扑排序 —— 有向图的顶点构成的一个线性序列</p>
<p>关键路径 —— 设计中从输入到输出经过的延时最长的逻辑路径</p>
<a id="more"></a>

<p><strong>数据结构课代码实现 之 图的拓扑排序与关键路径</strong></p>
<h2 id="简要理解"><a href="#简要理解" class="headerlink" title="简要理解"></a>简要理解</h2><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>使用对一个有向无环图 (Directed Acyclic Graph简称DAG) G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边 &lt;u,v&gt; 存在，则 u 在线性序列中出现在 v 之前</p>
<p>同一图的拓扑排序不唯一</p>
<h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><p>对图先进行拓扑排序，求出每一个活动 (图中的边) 最早的发生时间 (用对应边的起点保存)，用栈将拓扑排序储存，再进行逆拓扑排序，求出每一个活动的最迟发生时间 (用对应边的终点保存)，如果活动的最早发生时间与最迟发生时间相等，则该活动为关键活动</p>
<p>附上之前的文章：</p>
<p><a href="https://www.woolym.com/algorithm/graph-theory/655.html">有向图的拓扑排序</a></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>邻接表存图</p>
<h3 id="拓扑排序-1"><a href="#拓扑排序-1" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>这里用栈实现，亦可用队列实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Topologic</span><span class="params">(ALGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> indegree[G.vexnum]; <span class="comment">// 用数组保存每个结点的入度</span></span><br><span class="line">    <span class="built_in">memset</span>(indegree, <span class="number">0</span>, <span class="keyword">sizeof</span>(indegree));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">for</span>(ArcNode* p = G.vertices[i].firstarc;p-&gt;nextarc != <span class="literal">NULL</span>;p = p-&gt;nextarc)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k = p-&gt;adjvex;</span><br><span class="line">            indegree[k]++; <span class="comment">// 计算入度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s; <span class="comment">// 用栈来保存入度为 0 的结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line">        <span class="keyword">if</span>(!indegree[i])</span><br><span class="line">            s.push(i); <span class="comment">// 先找一遍嗷</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">// 记录拓扑排序过程中的结点数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = s.top(); <span class="comment">// 每次出栈一个入度为 0 的一个结点 并将其并入拓扑排序中</span></span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;当前入度为零的节点的序号为：&quot;</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;保存的数据为：&quot;</span> &lt;&lt; G.vertices[t].data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">for</span>(ArcNode* p = G.vertices[t].firstarc;p-&gt;nextarc != <span class="literal">NULL</span>;p = p-&gt;nextarc)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k = p-&gt;adjvex;  <span class="comment">// 用出栈结点更新与他相连的结点入度</span></span><br><span class="line">            <span class="keyword">if</span>(!(--indegree[k])) <span class="comment">// 入度为 0 入栈</span></span><br><span class="line">                s.push(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &lt; G.vexnum) <span class="comment">// 拓扑排序中的点小于图中点数 存在环</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ALGraph g;</span><br><span class="line">    CreateGraph(g);</span><br><span class="line">    Topologic(g);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关键路径-1"><a href="#关键路径-1" class="headerlink" title="关键路径"></a>关键路径</h3><p>最早开始时间 ：<code>ve(k) = max&#123;ve(j) + dut(&lt;j,k&gt;)&#125;</code> </p>
<p>结点 j 为 所有以结点 k 为尾的弧的头结点</p>
<p>活动的最早开始时间由之前所有活动中 用时最长的活动决定</p>
<p>最迟开始时间：<code>vl(j) = min&#123;vl(k) - dut(&lt;j,k&gt;)&#125;</code> </p>
<p>结点 j 为 所有以结点 k 为头的弧的尾结点</p>
<p>活动的最迟开始时间由之后所有活动中 用时最长的活动决定</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ve[MAX_VERTEX_NUM]; <span class="comment">// 保存每个活动的最早开始时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vl[MAX_VERTEX_NUM]; <span class="comment">// 保存每个活动的最迟开始时间                                                       </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Topologic</span><span class="params">(ALGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> indegree[G.vexnum];</span><br><span class="line">    <span class="built_in">memset</span>(indegree, <span class="number">0</span>, <span class="keyword">sizeof</span>(indegree));</span><br><span class="line">    <span class="built_in">memset</span>(ve, <span class="number">0</span>,<span class="keyword">sizeof</span>(ve));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">for</span>(ArcNode* p = G.vertices[i].firstarc;p-&gt;nextarc != <span class="literal">NULL</span>;p = p-&gt;nextarc)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k = p-&gt;adjvex;</span><br><span class="line">            indegree[k]++;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line">        <span class="keyword">if</span>(!indegree[i])</span><br><span class="line">            s.push(i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        T.push(t);  <span class="comment">// 用栈 T 保存逆拓扑排序</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;当前入度为零的节点的序号为：&quot;</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;保存的数据为：&quot;</span> &lt;&lt; G.vertices[t].data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">for</span>(ArcNode* p = G.vertices[t].firstarc;p-&gt;nextarc != <span class="literal">NULL</span>;p = p-&gt;nextarc)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k = p-&gt;adjvex;</span><br><span class="line">            <span class="keyword">if</span>(ve[k] &lt; ve[t] + p-&gt;cost)</span><br><span class="line">                ve[k] = ve[t] + p-&gt;cost; <span class="comment">// 活动的最早开始时间由之前所有活动中 用时最长的活动决定</span></span><br><span class="line">            <span class="keyword">if</span>(!(--indegree[k]))</span><br><span class="line">                s.push(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &lt; G.vexnum)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CriticalPach</span><span class="params">(ALGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!Topologic(G)) <span class="keyword">return</span> ERROR; <span class="comment">// 如果图中有环 则无拓扑序列 无关键路径</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line">        vl[i] = ve[G.vexnum - <span class="number">1</span>]; <span class="comment">// 初始化所有活动的最迟开始时间</span></span><br><span class="line">    <span class="keyword">while</span>(!T.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = T.top();</span><br><span class="line">        T.pop();</span><br><span class="line">        <span class="keyword">for</span>(ArcNode* p = G.vertices[t].firstarc;p-&gt;nextarc != <span class="literal">NULL</span>;p = p-&gt;nextarc)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k = p-&gt;adjvex;</span><br><span class="line">            <span class="keyword">int</span> dut = p-&gt;cost;</span><br><span class="line">            <span class="keyword">if</span>(vl[k] - dut &lt; vl[t]) vl[t] = vl[k] - dut; <span class="comment">// 活动的最迟开始时间由之后所有活动中 用时最长的活动决定</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(ArcNode* p = G.vertices[i].firstarc;p-&gt;nextarc != <span class="literal">NULL</span>;p = p-&gt;nextarc)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k = p-&gt;adjvex;</span><br><span class="line">            <span class="keyword">int</span> dut = p-&gt;cost;</span><br><span class="line">            <span class="keyword">int</span> ee = ve[i], el = vl[k] - dut;</span><br><span class="line">            <span class="keyword">char</span> tag = (ee == el) ? <span class="string">&#x27;*&#x27;</span> : <span class="string">&#x27; &#x27;</span>; <span class="comment">// 是否为关键路径</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; G.vertices[i].data &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; G.vertices[k].data &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; dut &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ee &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; el &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; tag &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ALGraph g1;</span><br><span class="line">    CreateGraphDouble(g1);</span><br><span class="line">    CriticalPach(g1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>图的最短路问题</title>
    <url>/algorithm/graph-theory/651.html</url>
    <content><![CDATA[<p>最短路问题 —— 若网络中的每条边都有一个数值（长度、成本、时间等），找出两节点之间总权和最小的路径</p>
<a id="more"></a>

<p><strong>数据结构课代码实现 之 最短路问题</strong></p>
<h2 id="简要理解"><a href="#简要理解" class="headerlink" title="简要理解"></a>简要理解</h2><p>Dijkstra算法：一个顶点到其余各顶点的最短路算法</p>
<p>Floyd算法：求多源汇最短路</p>
<h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><p>主要思想为维护一个 dist数组 保存起点到其余各点的最短路长度</p>
<p>初始化时将 dist数组中每个 dist[j] 初始化为起点到 j点的边长 （无边则初始化为INFINITY）</p>
<p>之后每次选择 dist数组 中最小的元素 将其对应点设置为已确定最短路径</p>
<p>并用其更新其余所有未确定最短路径的点的最短路长度</p>
<p><code>n - 1</code> 次操作后即可更新所有点的最短路</p>
<h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><p>用中转点 k 更新 点 i 到 点 j 的最短路径</p>
<p><code>d[i][j] = d[i][k] + d[k][j] </code></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>用邻接矩阵存图</p>
<h3 id="Dijkstra算法-1"><a href="#Dijkstra算法-1" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">int</span> vex;</span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Path</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ArcNode* first;             <span class="comment">// 用单链表保存起点到每个节点的路径</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;path[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">final</span>[MAX_VERTEX_NUM];    <span class="comment">// final数组 记录每个点的最短路是否被确定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(MGraph &amp;G, <span class="keyword">int</span> v0, Path* p, <span class="keyword">int</span> d[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">final</span>[i] = <span class="literal">false</span>;</span><br><span class="line">        p[i].num = <span class="number">1</span>;</span><br><span class="line">        p[i].first = (ArcNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));</span><br><span class="line">        p[i].first-&gt;vex = v0;</span><br><span class="line">        d[i] = G.arcs[v0][i].adj;</span><br><span class="line">        <span class="keyword">if</span>(d[i] &lt; INFINITY)</span><br><span class="line">        &#123;</span><br><span class="line">            p[i].first-&gt;next = (ArcNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));</span><br><span class="line">            p[i].first-&gt;next-&gt;vex = i;</span><br><span class="line">            p[i].num = <span class="number">2</span>;          <span class="comment">// 初始化路径</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> poi;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> min = INFINITY;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; G.vexnum;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">final</span>[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(d[j] &lt; min)</span><br><span class="line">                &#123;</span><br><span class="line">                    poi = j;</span><br><span class="line">                    min = d[j];       <span class="comment">// 每次在所有点中选择距离起点最近的点</span></span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span>[poi] = <span class="literal">true</span>;            <span class="comment">// 记录此点已确定最短路</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; G.vexnum;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 用已确定最短路的点更新其余所有未确定最短路的点的 dist</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">final</span>[j] &amp;&amp; (min + G.arcs[poi][j].adj &lt; d[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                d[j] = min + G.arcs[poi][j].adj;     </span><br><span class="line">                </span><br><span class="line">                ArcNode* clean = p[j].first;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; path[j].num;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    ArcNode* last = clean;</span><br><span class="line">                    clean = clean-&gt;next;</span><br><span class="line">                    <span class="built_in">free</span>(last);                    <span class="comment">// 删除 j点 原路径</span></span><br><span class="line">                &#125;           </span><br><span class="line"></span><br><span class="line">                p[j].first = (ArcNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));</span><br><span class="line"></span><br><span class="line">                ArcNode* tep = p[j].first;</span><br><span class="line">                ArcNode* tmp = p[poi].first;        <span class="comment">// 更新 起点到j点 的最短路径记录</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; p[poi].num;k++, tep = tep-&gt;next, tmp = tmp-&gt;next)</span><br><span class="line">                &#123;</span><br><span class="line">                    tep-&gt;vex = tmp-&gt;vex;</span><br><span class="line">                    tep-&gt;next = (ArcNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                p[j].num = p[poi].num;</span><br><span class="line">                tep-&gt;vex = j;</span><br><span class="line">                p[j].num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MGraph a;</span><br><span class="line">    CreateGraph(a);</span><br><span class="line">    <span class="keyword">int</span> d[a.vexnum];       <span class="comment">// 维护一个 dist数组储存起点到其余各点的最短路径</span></span><br><span class="line">    dijkstra(a, <span class="number">0</span>, path, d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入起点与要查询的点(输入点的储存值)：&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    </span><br><span class="line">    x = LocateVex(a, x);</span><br><span class="line">    y = LocateVex(a, y);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;号结点到&quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;号结点的最短路长度为：&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d[y] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;号结点到&quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;号结点的最短路路径长度为：&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; path[y].num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    ArcNode* j = path[y].first;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;记录的路径为：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; path[y].num;i++, j = j-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; j-&gt;vex &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Floyd算法-1"><a href="#Floyd算法-1" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">int</span> vex;</span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Path</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ArcNode* first;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;**path;          <span class="comment">// 单链表储存一点到另一点最短路径</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">(MGraph &amp;G, Path** p, <span class="keyword">int</span>** d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; G.vexnum;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            p[i][j].num = <span class="number">1</span>;</span><br><span class="line">            p[i][j].first = (ArcNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));</span><br><span class="line">            p[i][j].first-&gt;vex = i;</span><br><span class="line">            d[i][j] = G.arcs[i][j].adj;</span><br><span class="line">            <span class="keyword">if</span>(d[i][j] &lt; INFINITY)</span><br><span class="line">            &#123;</span><br><span class="line">                p[i][j].first-&gt;next = (ArcNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));</span><br><span class="line">                p[i][j].first-&gt;next-&gt;vex = j;</span><br><span class="line">                p[i][j].num = <span class="number">2</span>;</span><br><span class="line">            &#125;                           <span class="comment">// 初始化路径</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; G.vexnum;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; G.vexnum;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(d[i][k] + d[k][j] &lt; d[i][j])    </span><br><span class="line">                &#123;</span><br><span class="line">                    d[i][j] = d[i][k] + d[k][j];      <span class="comment">// 满足条件 更新最短路径</span></span><br><span class="line"></span><br><span class="line">                    ArcNode* clean = p[i][j].first;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>;u &lt; path[i][j].num;u++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ArcNode* last = clean;</span><br><span class="line">                        clean = clean-&gt;next;</span><br><span class="line">                        <span class="built_in">free</span>(last);                    <span class="comment">// 删除 i 到 j 点的原路径</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    p[i][j].first = (ArcNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));</span><br><span class="line"></span><br><span class="line">                    ArcNode* tep = p[i][j].first;</span><br><span class="line">                    ArcNode* tmp = p[i][k].first;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>;u &lt; p[i][k].num;u++, tep = tep-&gt;next, tmp = tmp-&gt;next)</span><br><span class="line">                    &#123;</span><br><span class="line">                        tep-&gt;vex = tmp-&gt;vex;</span><br><span class="line">                        tep-&gt;next = (ArcNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    tmp = p[k][j].first-&gt;next; <span class="comment">// i 到 k 的路径的最后一个点 与 k 到 j 的路径的第一个点是重复的，删除其一</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>;u &lt; p[k][j].num - <span class="number">1</span>;u++, tep = tep-&gt;next, tmp = tmp-&gt;next)</span><br><span class="line">                    &#123;</span><br><span class="line">                        tep-&gt;vex = tmp-&gt;vex;</span><br><span class="line">                        tep-&gt;next = (ArcNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    p[i][j].num = p[i][k].num + p[k][j].num - <span class="number">1</span>;  <span class="comment">// i 到 k 的路径的最后一个点 与 k 到 j 的路径的第一个点是重复的，长度减一</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MGraph a;</span><br><span class="line">    CreateGraph(a);</span><br><span class="line">    <span class="keyword">int</span>** d;</span><br><span class="line">    path = (Path**)<span class="built_in">malloc</span>(a.vexnum * <span class="keyword">sizeof</span>(Path*));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; a.vexnum;i++)</span><br><span class="line">        path[i] = (Path*)<span class="built_in">malloc</span>(a.vexnum * <span class="keyword">sizeof</span>(Path));</span><br><span class="line"></span><br><span class="line">    d = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(a.vexnum * <span class="keyword">sizeof</span>(<span class="keyword">int</span>*));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; a.vexnum;i++)</span><br><span class="line">        d[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(a.vexnum * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    Floyd(a, path, d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入查询的起点与终点(输入点的储存值)：&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line"></span><br><span class="line">    x = LocateVex(a, x);</span><br><span class="line">    y = LocateVex(a, y);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;号结点到&quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;号结点的最短路长度为：&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d[x][y] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;号结点到&quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;号结点的最短路路径长度为：&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; path[x][y].num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    ArcNode* tep = path[x][y].first;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;记录的路径为：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>;u &lt; path[x][y].num;u++, tep = tep-&gt;next)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tep-&gt;vex &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>图的最小生成树</title>
    <url>/algorithm/graph-theory/647.html</url>
    <content><![CDATA[<p>最小生成树 —— 包含 原图 中的所有 n 个结点 并且 有保持图连通的最少的边</p>
<p>一个有 n 个结点的 连通图 的生成树是 原图 的 极小连通子图</p>
<a id="more"></a>

<p><strong>数据结构课代码实现 之 最小生成树</strong></p>
<h2 id="简要理解"><a href="#简要理解" class="headerlink" title="简要理解"></a>简要理解</h2><p>求图的最小生成树的两种算法：Prim（适用于稠密图） 与 Kruskal （适用于稀疏图）</p>
<h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><p>维护一个 点集合 和一个 边集合 用来保存最小生成树，点集合初始只有一个存在于该图的点，边集合初始为空集</p>
<p>每次更新操作都是寻找一条边 (u, v)，将该边并入边集合中，将点 v 并入点集合中</p>
<p>点 u 为当前点集合中的一个点，点 v 为不在点集合中的一个点</p>
<p>边 (u, v) 满足条件为不在边集合中并且代价最小</p>
<p>直至图中的所有点都进入点集合 此时边集合中必有 图的点数 - 1条边</p>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p>令最小生成树的初始状态为只有 n 个顶点而无边的非连通图，图中每个点都是一个连通分量</p>
<p>将所有图中所有边按照权值大小由小到大排序</p>
<p>按次序对边进行检查，如果当前边依附的顶点落在不同的连通分量上，则将此边加入至最小生成树中</p>
<p>否则舍弃此边继续检查下一条代价最小的边</p>
<p>直至所有顶点都在同一个连通分量上</p>
<p>附上之前的文章：</p>
<p><a href="/algorithm/graph-theory/425.html">最小生成树</a></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>用邻接矩阵的储存结构实现</p>
<h3 id="Prim代码"><a href="#Prim代码" class="headerlink" title="Prim代码"></a>Prim代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">close</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;</span><br><span class="line">    <span class="keyword">int</span> lowcost;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">&#125;closeedge[MAX_VERTEX_NUM];    <span class="comment">// 开一个结构体数组储存图中所有点到集合的距离</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(close a, close b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.lowcost &lt; b.lowcost)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mininum</span><span class="params">(<span class="keyword">int</span> num, close* closeedge)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    close closeedge1[num];      <span class="comment">// 另开一个结构体数组用来排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        closeedge1[i].adjvex = closeedge[i].adjvex;</span><br><span class="line">        closeedge1[i].lowcost = closeedge[i].lowcost;</span><br><span class="line">        closeedge1[i].pos = closeedge[i].pos;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sort(closeedge1, closeedge1 + num, cmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; num;i++)</span><br><span class="line">        <span class="keyword">if</span>(closeedge1[i].lowcost &gt; <span class="number">0</span>)            <span class="comment">// 把已在集合中的边设 0（对应点到集合cost 为 0）</span></span><br><span class="line">            <span class="keyword">return</span> closeedge1[i].pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MiniSpanTree_PRIM</span><span class="params">(MGraph G, <span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = LocateVex(G, u);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; G.vexnum;j++)</span><br><span class="line">        <span class="keyword">if</span>(j != k)</span><br><span class="line">            closeedge[j] = &#123;u, G.arcs[k][j].adj, j&#125;;</span><br><span class="line">	closeedge[k].pos = k;</span><br><span class="line">	closeedge[k].lowcost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        k = mininum(G.vexnum, closeedge);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; closeedge[k].adjvex &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; G.vexs[k] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        closeedge[k].lowcost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; G.vexnum;j++)</span><br><span class="line">            <span class="keyword">if</span>(G.arcs[k][j].adj &lt; closeedge[j].lowcost)</span><br><span class="line">                closeedge[j] = &#123;G.vexs[k], G.arcs[k][j].adj, j&#125;;        <span class="comment">// 用新加入的点更新其余所有点到集合的代价</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MGraph a;</span><br><span class="line">    CreateGraph(a);</span><br><span class="line">    MiniSpanTree_PRIM(a, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Kruskal代码"><a href="#Kruskal代码" class="headerlink" title="Kruskal代码"></a>Kruskal代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> st;</span><br><span class="line">    <span class="keyword">int</span> en;</span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[MAX_VERTEX_NUM], peo[MAX_VERTEX_NUM];        <span class="comment">// 并查集检查两个点是否存在于一个连通分量中</span></span><br><span class="line">                                                    <span class="comment">// peo数组 保存当前集合元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>             <span class="comment">// 并查集 find 操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x] != x)</span><br><span class="line">        <span class="keyword">return</span> fa[x] = find(fa[x]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a, edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.cost &lt; b.cost)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">(MGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">2</span> * G.arcnum;         <span class="comment">// 无向图乘二</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> <span class="title">edges</span>[<span class="title">num</span>];</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; G.vexnum;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(G.arcs[i][j].adj &lt; INFINITY)</span><br><span class="line">                edges[cnt++] = &#123;i, j, G.arcs[i][j].adj&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(edges, edges + num, cmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        peo[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; num;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = edges[j].st, y = edges[j].en;</span><br><span class="line">        x = find(x);</span><br><span class="line">        y = find(y);</span><br><span class="line">        <span class="keyword">if</span>(x != y)</span><br><span class="line">        &#123;</span><br><span class="line">            fa[y] = x;</span><br><span class="line">            peo[x] += peo[y];       <span class="comment">// 更新集合成员数</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;起点：&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; G.vexs[edges[j].st] &lt;&lt; <span class="string">&quot;终点：&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; G.vexs[edges[j].en] &lt;&lt; <span class="string">&quot;权值：&quot;</span> &lt;&lt; edges[j].cost &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(peo[x] == G.vexnum)</span><br><span class="line">            <span class="keyword">break</span>;                  <span class="comment">// 如果 集合点数 与 图的点数相同 生成树建立完毕</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MGraph a;</span><br><span class="line">    CreateGraph(a);</span><br><span class="line">    Kruskal(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>图的深度优先遍历(DFS) 与 广度优先遍历(BFS)</title>
    <url>/algorithm/graph-theory/645.html</url>
    <content><![CDATA[<p>DFS —— 在一条路上一路到底的遍历</p>
<p>BFS —— 层层递进的遍历</p>
<a id="more"></a>

<p><strong>数据结构课代码实现 之 深度优先遍历(DFS) 与 广度优先遍历(BFS)</strong></p>
<h2 id="简要理解"><a href="#简要理解" class="headerlink" title="简要理解"></a>简要理解</h2><p>附之前的三篇文章：</p>
<p><a href="/algorithm/graph-theory/458.html">DFS（深度优先遍历） 与 BFS（广度优先遍历）</a></p>
<p><a href="/algorithm/graph-theory/470.html">DFS经典问题</a></p>
<p><a href="/algorithm/graph-theory/473.html">BFS经典问题</a></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>这里提供的代码默认都是从 0 号地址的结点开始的，请自行修改</p>
<p>请区分点的 地址 与 储存的数据！</p>
<h3 id="邻接表存图"><a href="#邻接表存图" class="headerlink" title="邻接表存图"></a>邻接表存图</h3><h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ALGraph g, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BFS顺序遍历下当前点的储存值为：&quot;</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; g.vertices[i].data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(ALGraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;ArcNode *&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">        &#123;</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            visit(G, i);</span><br><span class="line">            <span class="keyword">if</span>(G.vertices[i].firstarc != <span class="literal">NULL</span>)</span><br><span class="line">                q.push(G.vertices[i].firstarc);</span><br><span class="line">            <span class="keyword">while</span>(!q.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                ArcNode* t = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = t-&gt;adjvex;t-&gt;nextarc != <span class="literal">NULL</span>;t = t-&gt;nextarc, j = t-&gt;adjvex)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!visited[j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        visited[j] = <span class="literal">true</span>;</span><br><span class="line">                        visit(G, j);</span><br><span class="line">                        q.push(G.vertices[j].firstarc);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ALGraph g;</span><br><span class="line">    CreateGraph(g);</span><br><span class="line">    BFSTraverse(g);   </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ALGraph g, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;DFS顺序遍历下当前点的储存值为： &quot;</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; g.vertices[i].data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(ALGraph g, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    visited[i] = <span class="literal">true</span>; </span><br><span class="line">    visit(g, i);</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    ArcNode* k;</span><br><span class="line">    <span class="keyword">for</span>(j = g.vertices[i].firstarc-&gt;adjvex, k = g.vertices[i].firstarc;k-&gt;nextarc != <span class="literal">NULL</span>;k = k-&gt;nextarc, j = k-&gt;adjvex)</span><br><span class="line">        <span class="keyword">if</span>(!visited[j])</span><br><span class="line">			DFS(g, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(ALGraph g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; g.vexnum;i++)</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; g.vexnum;i++)</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">            DFS(g, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ALGraph g;</span><br><span class="line">    CreateGraph(g);</span><br><span class="line">    DFSTraverse(g);   </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="邻接矩阵存图"><a href="#邻接矩阵存图" class="headerlink" title="邻接矩阵存图"></a>邻接矩阵存图</h3><h4 id="BFS-1"><a href="#BFS-1" class="headerlink" title="BFS"></a>BFS</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(MGraph g, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BFS顺序遍历下当前点的储存值为： &quot;</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; g.vexs[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(MGraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++) </span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">        &#123;</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            visit(G, i);</span><br><span class="line">            q.push(i);</span><br><span class="line">            <span class="keyword">while</span>(!q.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; G.vexnum;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(G.arcs[t][j].adj != INFINITY &amp;&amp; !visited[j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        visited[j] = <span class="literal">true</span>;</span><br><span class="line">                        visit(G, j);</span><br><span class="line">                        q.push(j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MGraph a;</span><br><span class="line">    CreateGraph(a);</span><br><span class="line">    BFSTraverse(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(MGraph g, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;DFS顺序遍历下当前点的储存值为： &quot;</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; g.vexs[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(MGraph G, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    visited[i] = <span class="literal">true</span>;</span><br><span class="line">    visit(G, i);</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; G.vexnum;k++)</span><br><span class="line">        <span class="keyword">if</span>(!visited[k] &amp;&amp; G.arcs[i][k].adj != INFINITY)</span><br><span class="line">            DFS(G, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(MGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">            DFS(G, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MGraph a;</span><br><span class="line">    CreateGraph(a);</span><br><span class="line">    DFSTraverse(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>邻接表 与 邻接矩阵</title>
    <url>/algorithm/data-structure/641.html</url>
    <content><![CDATA[<p>邻接表 —— 稀疏图使用的图的储存结构</p>
<p>邻接矩阵 —— 稠密图使用的图的储存结构</p>
<a id="more"></a>

<p><strong>数据结构课代码实现 之 邻接表 与 邻接矩阵</strong></p>
<h2 id="简要理解"><a href="#简要理解" class="headerlink" title="简要理解"></a>简要理解</h2><p>邻接表 —— 链式储存结构 对图中每个顶点建立一个单链表来表示依附于该节点的边</p>
<p>邻接矩阵 —— 使用两个数组分别储存数据元素 (顶点) 的信息 和 数据元素之间的关系 (边或弧) 的信息</p>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;                    <span class="comment">// 该弧指向的顶点的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">nextarc</span>;</span>       <span class="comment">// 指向下一条弧的指针</span></span><br><span class="line">    <span class="comment">//InfoType *info;                 该弧相关信息的指针</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;                      <span class="comment">// 顶点信息</span></span><br><span class="line">    ArcNode *firstarc;             <span class="comment">// 指向第一条依附该顶点的弧的指针</span></span><br><span class="line">&#125;VNode, AdjList[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    AdjList vertices;              </span><br><span class="line">    <span class="keyword">int</span> vexnum, arcnum;            <span class="comment">// 图的当前 顶点数 和 弧数</span></span><br><span class="line">    <span class="keyword">int</span> kind;                      <span class="comment">// 图的种类标志</span></span><br><span class="line">&#125;ALGraph;</span><br></pre></td></tr></table></figure>

<h4 id="创建邻接表"><a href="#创建邻接表" class="headerlink" title="创建邻接表"></a>创建邻接表</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span><span class="params">(ALGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入图的点数 与 弧数：&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; G.vexnum &gt;&gt; G.arcnum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入第 &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; 号节点的data&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; G.vertices[i].data;</span><br><span class="line">        G.vertices[i].firstarc = (ArcNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));</span><br><span class="line">        ArcNode* temp = G.vertices[i].firstarc;</span><br><span class="line">        <span class="keyword">char</span> x;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入第 &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; 号节点的邻接点，空格分开，#结束&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span>(x != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">            temp-&gt;adjvex = x - <span class="number">48</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp-&gt;nextarc = (ArcNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));</span><br><span class="line">            temp = temp-&gt;nextarc;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            <span class="keyword">if</span>(x != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                temp-&gt;adjvex = x - <span class="number">48</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;nextarc = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><h4 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span>DG, DN, UDG, UDN&#125; GraphKind;          <span class="comment">// &#123;有向图，有向网，无向图，无向网&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcCell</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> adj;                                       <span class="comment">// 有权图 表顶点之间的权值 </span></span><br><span class="line">    											   <span class="comment">// 无权图用 0 或 1 表是否相邻</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可储存一些与弧相关的信息</span></span><br><span class="line">&#125;ArcCell, AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];  </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> vexs[MAX_VERTEX_NUM];                      <span class="comment">// 顶点向量        </span></span><br><span class="line">    AdjMatrix arcs;                                <span class="comment">// 邻接矩阵</span></span><br><span class="line">    <span class="keyword">int</span> vexnum, arcnum;                            <span class="comment">// 图的 顶点数 和 弧数</span></span><br><span class="line">    GraphKind kind;                                <span class="comment">// 图的种类</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure>

<h4 id="LocateVex操作"><a href="#LocateVex操作" class="headerlink" title="LocateVex操作"></a>LocateVex操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(MGraph g, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; g.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(g.vexs[i] == x)           <span class="comment">// 输入顶点向量值 求 顶点坐标</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建矩阵"><a href="#创建矩阵" class="headerlink" title="创建矩阵"></a>创建矩阵</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CreateUDN</span><span class="params">(MGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入图的点数 与 弧数：&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; G.vexnum &gt;&gt; G.arcnum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;依次输入图的各点的 值：&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; G.vexs[i];</span><br><span class="line">	&#125; 	</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.vexnum; j++)</span><br><span class="line">            G.arcs[i][j].adj = INFINITY;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; G.arcnum; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v1, v2, w;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;依次输入每条弧的 起点 与 终点(输入点的值 不是坐标) 与 权值：&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;</span><br><span class="line">        i = LocateVex(G, v1);</span><br><span class="line">        j = LocateVex(G, v2);</span><br><span class="line">        G.arcs[i][j].adj = w;</span><br><span class="line">        G.arcs[j][i] = G.arcs[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CreateGraph</span><span class="params">(MGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入图的类型：&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="string">&quot;DG&quot;</span>) G.kind = DG;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="string">&quot;DN&quot;</span>) G.kind = DN;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="string">&quot;UDG&quot;</span>) G.kind = UDG;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="string">&quot;UDN&quot;</span>) G.kind = UDN;</span><br><span class="line">    <span class="keyword">switch</span>(G.kind)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> DG: <span class="keyword">return</span> CreateDG(G);</span><br><span class="line">        <span class="keyword">case</span> DN: <span class="keyword">return</span> CreateDN(G);</span><br><span class="line">        <span class="keyword">case</span> UDN: <span class="keyword">return</span> CreateUDN(G);</span><br><span class="line">        <span class="keyword">case</span> UDG: <span class="keyword">return</span> CreateUDG(G);</span><br><span class="line">        <span class="keyword">default</span> : <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无向图的 弧 相当于是有向图 给相应起点与终点间 建立两个方向的 弧</p>
<p>有向图 有向网 无向图就不写了，图的种类 决定了 创图时是否正反建边 或者 是否存在权值</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>哈夫曼树 (Huffman Tree) 的理解与代码实现</title>
    <url>/algorithm/data-structure/637.html</url>
    <content><![CDATA[<p>哈夫曼编码 —— 二进制前缀编码，以 n 个字符的出现频率作为权重，以求得字长最短的二进制编码</p>
<p>哈夫曼树 —— 采用二叉树的形式储存编码格式</p>
<a id="more"></a>

<blockquote>
<p>前缀编码：字符集中任一字符的编码都不是其它字符的编码的前缀</p>
</blockquote>
<p><strong>数据结构课代码实现 之 哈夫曼树</strong></p>
<h2 id="简要理解"><a href="#简要理解" class="headerlink" title="简要理解"></a>简要理解</h2><p>在已知每个字符结点 及其 权重的情况下，每次选择两个权重最小的字符结点，创建一个新的结点</p>
<p>将新结点的左右孩子结点设置为选择的两个字符结点，设置新结点权重为两子结点权重之和</p>
<p>设置两个字符结点的双亲结点为新结点</p>
<p>标记两个子结点已被选择过，并将在下次选择时将新结点设为可选择</p>
<p>有 <code>n</code> 个字符的哈夫曼树 即 有 <code>n</code> 个叶子结点的哈夫曼树共有 <code>2n -  1</code> 个结点</p>
<p>所以在 <code>n - 1</code> 次选择过后哈夫曼树即被建立</p>
<h2 id="具体理解-与-代码实现"><a href="#具体理解-与-代码实现" class="headerlink" title="具体理解 与 代码实现"></a>具体理解 与 代码实现</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a, b) &#123;int c = a; a = b; b = c;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> parent, lchild, rchild;</span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">&#125; HTNode, *HuffmanTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> **HuffmanCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> *visit;                    <span class="comment">// 储存结点是否被选择过 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; x;      <span class="comment">// 读取模式2 下字符与权值储存在 map 容器中</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">w</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> w;             <span class="comment">// 在 Select 函数中排序临时使用的结构体容器</span></span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(w a, w b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.w &lt; b.w)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Select-函数"><a href="#Select-函数" class="headerlink" title="Select 函数"></a>Select 函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Select</span><span class="params">(HuffmanTree HT, <span class="keyword">int</span> i, <span class="keyword">int</span> &amp;s1, <span class="keyword">int</span> &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    w we[i];                    <span class="comment">// 使用临时的结构体 排序不改变原结构顺序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        we[j].w = HT[j].weight;</span><br><span class="line">        we[j].pos = j;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(we + <span class="number">1</span>, we + i + <span class="number">1</span>, cmp);  <span class="comment">// 未使用 0 地址</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visit[we[j].pos])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1 == <span class="number">0</span>)</span><br><span class="line">                s1 = we[j].pos;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s2 == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s2 = we[j].pos;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s1 &gt; s2)</span><br><span class="line">        swap(s1, s2);                <span class="comment">// 确保 s1 &lt;= s2</span></span><br><span class="line">    visit[s1] = <span class="literal">true</span>;</span><br><span class="line">    visit[s2] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="哈夫曼建树编码的过程"><a href="#哈夫曼建树编码的过程" class="headerlink" title="哈夫曼建树编码的过程"></a>哈夫曼建树编码的过程</h3><h4 id="读取模式1-预先设置好每个字符的-权重-手动输入对应字符"><a href="#读取模式1-预先设置好每个字符的-权重-手动输入对应字符" class="headerlink" title="读取模式1 (预先设置好每个字符的 权重 手动输入对应字符)"></a>读取模式1 (预先设置好每个字符的 权重 手动输入对应字符)</h4><h5 id="方法一-由-叶子结点-到-根-编码"><a href="#方法一-由-叶子结点-到-根-编码" class="headerlink" title="方法一  (由 叶子结点 到 根 编码)"></a>方法一  (由 叶子结点 到 根 编码)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanCoding</span><span class="params">(HuffmanTree &amp;HT, HuffmanCode &amp;HC, <span class="keyword">unsigned</span> <span class="keyword">int</span> *w, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">2</span> * n - <span class="number">1</span>;</span><br><span class="line">    HT = (HuffmanTree)<span class="built_in">malloc</span>((m + <span class="number">1</span>) * <span class="keyword">sizeof</span>(HTNode)); <span class="comment">// 2n - 1 个空间，不使用 0 地址所以多开一个位置</span></span><br><span class="line">    HuffmanTree p = HT + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入各字符：(不需要空格分开，回车结束)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i, ++p, ++w)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> x;</span><br><span class="line">        x = getchar();</span><br><span class="line">        *p = &#123;*w, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, x&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> s1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> s2 = <span class="number">0</span>;</span><br><span class="line">        Select(HT, i - <span class="number">1</span>, s1, s2);</span><br><span class="line">        HT[s1].parent = i;</span><br><span class="line">        HT[s2].parent = i;</span><br><span class="line">        HT[i].lchild = s1;</span><br><span class="line">        HT[i].rchild = s2;</span><br><span class="line">        HT[i].weight = HT[s1].weight + HT[s2].weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HT[m].parent = <span class="number">0</span>;       <span class="comment">//编码时访问至根节点会查询根节点的双亲节点 所以初始化成0</span></span><br><span class="line">    <span class="comment">// 查了好久才发现的问题...</span></span><br><span class="line">    HC = (HuffmanCode)<span class="built_in">malloc</span>((n + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">char</span> *));</span><br><span class="line">    <span class="keyword">char</span> *cd = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));        <span class="comment">// cd 是临时储存编码过程的空间</span></span><br><span class="line">    cd[n - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> start = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> f, c;</span><br><span class="line">        <span class="keyword">for</span> (c = i, f = HT[i].parent; f != <span class="number">0</span>; c = f, f = HT[f].parent)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (HT[f].lchild == c)</span><br><span class="line">                cd[--start] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cd[--start] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HC[i] = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>((n - start) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">        <span class="built_in">strcpy</span>(HC[i], &amp;cd[start]);          <span class="comment">// \0前的所有内容复制至 HC[i] 包括 \0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(cd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="方法二-由-根-向-叶子结点-编码"><a href="#方法二-由-根-向-叶子结点-编码" class="headerlink" title="方法二 (由 根 向 叶子结点 编码)"></a>方法二 (由 根 向 叶子结点 编码)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanCoding2</span><span class="params">(HuffmanTree &amp;HT, HuffmanCode &amp;HC, <span class="keyword">unsigned</span> <span class="keyword">int</span>* w, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 省略略略略略略略略略略略略略略略略略略略略略略略略略略略略略略略略略略 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 同方法一的数据读入 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *cd = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    HC = (HuffmanCode)<span class="built_in">malloc</span>((n + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">char</span> *));</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">2</span> * n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cdlen = <span class="number">0</span>;              <span class="comment">// 编码过程中维护的 cd 长度</span></span><br><span class="line">    HT[p].parent = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; i++)</span><br><span class="line">        HT[i].weight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)                   <span class="comment">// 最后会指向 2n - 1 结点的父亲 设置的是 0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (HT[p].weight == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            HT[p].weight = <span class="number">1</span>;   <span class="comment">// 标记该结点左孩子结点已被遍历过</span></span><br><span class="line">            <span class="keyword">if</span> (HT[p].lchild != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                p = HT[p].lchild;</span><br><span class="line">                cd[cdlen++] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (HT[p].rchild == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                HC[p] = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>((cdlen + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">                cd[cdlen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="built_in">strcpy</span>(HC[p], cd);      <span class="comment">// 左右孩子结点都为空为叶子结点 完成编码一次</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (HT[p].weight == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            HT[p].weight = <span class="number">2</span>;           <span class="comment">// 标记该结点右孩子结点已被遍历过</span></span><br><span class="line">            <span class="keyword">if</span> (HT[p].rchild != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                p = HT[p].rchild;</span><br><span class="line">                cd[cdlen++] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            HT[p].weight = <span class="number">0</span>;</span><br><span class="line">            p = HT[p].parent;           <span class="comment">// 退回双亲结点</span></span><br><span class="line">            --cdlen;                    <span class="comment">// 长度减一</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="读取模式2-输入一段话来计算-字符-与-相应权重"><a href="#读取模式2-输入一段话来计算-字符-与-相应权重" class="headerlink" title="读取模式2 (输入一段话来计算 字符 与 相应权重)"></a>读取模式2 (输入一段话来计算 字符 与 相应权重)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanCoding3</span><span class="params">(HuffmanTree &amp;HT, HuffmanCode &amp;HC,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">2</span> * n - <span class="number">1</span>;</span><br><span class="line">    HT = (HuffmanTree)<span class="built_in">malloc</span>((m + <span class="number">1</span>) * <span class="keyword">sizeof</span>(HTNode));</span><br><span class="line">    HuffmanTree p = HT + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;::iterator it;       <span class="comment">// 迭代器遍历 map</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;字符&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;权重&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (it = x.begin(); it != x.end(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        *p = &#123;it-&gt;second, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, it-&gt;first&#125;;</span><br><span class="line">        p++;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;    &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 省略略略略略略略略略略略略略略略略略略略略略略略略略略略略略略略略略略 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 同读取模式1的建树编码 */</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输入原字段输出哈夫曼编码"><a href="#输入原字段输出哈夫曼编码" class="headerlink" title="输入原字段输出哈夫曼编码"></a>输入原字段输出哈夫曼编码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prtHuf</span><span class="params">(HuffmanTree HT, HuffmanCode HC, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *read;</span><br><span class="line">    read = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">1000</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));     <span class="comment">// 不够你就开大点</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    a = getchar();</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (a != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a == HT[i].data)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">strcpy</span>(read + cnt, HC[i]);      <span class="comment">//暴力写法，不要在意</span></span><br><span class="line">                cnt += <span class="built_in">strlen</span>(HC[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Huffman编码：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; read &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输入哈夫曼编码输出原字段"><a href="#输入哈夫曼编码输出原字段" class="headerlink" title="输入哈夫曼编码输出原字段"></a>输入哈夫曼编码输出原字段</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prtData</span><span class="params">(HuffmanTree HT, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">2</span> * n - <span class="number">1</span>;            <span class="comment">// 由根节点开始译码</span></span><br><span class="line">    <span class="keyword">char</span> *ans = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">1000</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));        <span class="comment">// 不够你就开大点</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    a = getchar();</span><br><span class="line">    <span class="keyword">while</span> (a != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            pos = HT[pos].lchild;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            pos = HT[pos].rchild;</span><br><span class="line">        <span class="keyword">if</span> (HT[pos].lchild == <span class="number">0</span> || HT[pos].rchild == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[cnt++] = HT[pos].data;</span><br><span class="line">            pos = <span class="number">2</span> * n - <span class="number">1</span>;                <span class="comment">// 到叶子结点后返回根节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        a = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">    ans[++cnt] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;原字段：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1.手动输入字符与权重&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;2.字段自动识别&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;请输入相应序号：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> mode;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; mode;</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">if</span> (mode == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入字符个数：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> *w = (<span class="keyword">unsigned</span> <span class="keyword">int</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>));</span><br><span class="line">        visit = (<span class="keyword">bool</span> *)<span class="built_in">malloc</span>((<span class="number">2</span> * n + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">bool</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span> * n + <span class="number">1</span>; i++)</span><br><span class="line">            visit[i] = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入各字符权重：(空格分开回车结束)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line">        getchar();</span><br><span class="line">        HuffmanCode Code, Code1;</span><br><span class="line">        HuffmanTree Tree;</span><br><span class="line">        HuffmanCoding(Tree, Code, w, n);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入原字段,以#结束： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        prtHuf(Tree, Code, n);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入Huffman编码,以#结束：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        prtData(Tree, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mode == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入一段话：(以#结束)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">char</span> a;</span><br><span class="line">        a = getchar();</span><br><span class="line">        <span class="keyword">while</span> (a != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!x.count(a))</span><br><span class="line">            &#123;</span><br><span class="line">                x[a] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                x[a]++;</span><br><span class="line">            &#125;</span><br><span class="line">            a = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = x.size();</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> *w = (<span class="keyword">unsigned</span> <span class="keyword">int</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>));</span><br><span class="line">        visit = (<span class="keyword">bool</span> *)<span class="built_in">malloc</span>((<span class="number">2</span> * n + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">bool</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span> * n + <span class="number">1</span>; i++)</span><br><span class="line">            visit[i] = <span class="literal">false</span>;</span><br><span class="line">        HuffmanCode Code;</span><br><span class="line">        HuffmanTree Tree;</span><br><span class="line">        HuffmanCoding3(Tree, Code, n);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入原字段,以#结束： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        prtHuf(Tree, Code, n);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入Huffman编码,以#结束：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        prtData(Tree, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="给个数据"><a href="#给个数据" class="headerlink" title="给个数据"></a>给个数据</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.手动输入字符与权重</span><br><span class="line">2.字段自动识别</span><br><span class="line">请输入相应序号：</span><br><span class="line">2</span><br><span class="line">请输入一段话：(以#结束)</span><br><span class="line">Youth is not a time of life; it is a state of mind. It is not a matter of rosy cheeks, red lips and supple knees. It is a matter of the will, a quality of the imagination, vigor of the emotions; it is the freshness of the deep spring of life.#</span><br><span class="line">字符 权重</span><br><span class="line">     51</span><br><span class="line">,    3</span><br><span class="line">.    3</span><br><span class="line">;    2</span><br><span class="line">I    2</span><br><span class="line">Y    1</span><br><span class="line">a    12</span><br><span class="line">c    1</span><br><span class="line">d    4</span><br><span class="line">e    22</span><br><span class="line">f    11</span><br><span class="line">g    3</span><br><span class="line">h    8</span><br><span class="line">i    20</span><br><span class="line">k    2</span><br><span class="line">l    7</span><br><span class="line">m    6</span><br><span class="line">n    10</span><br><span class="line">o    16</span><br><span class="line">p    5</span><br><span class="line">q    1</span><br><span class="line">r    7</span><br><span class="line">s    16</span><br><span class="line">t    22</span><br><span class="line">u    3</span><br><span class="line">v    1</span><br><span class="line">w    1</span><br><span class="line">y    2</span><br><span class="line">请输入原字段,以#结束：</span><br><span class="line">I think i am a pop man.#</span><br><span class="line">Huffman编码：</span><br><span class="line">1001101000101001011001101010011100011000001100111000011000110111101011011100011100110110101111111</span><br><span class="line">请输入Huffman编码,以#结束：</span><br><span class="line">1001101000101001011001101010011100011000001100111000011000110111101011011100011100110110101111111#</span><br><span class="line">原字段：</span><br><span class="line">I think i am a pop man.</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.手动输入字符与权重</span><br><span class="line">2.字段自动识别</span><br><span class="line">请输入相应序号：</span><br><span class="line">1</span><br><span class="line">请输入字符个数：</span><br><span class="line">8</span><br><span class="line">请输入各字符权重：(空格分开回车结束)</span><br><span class="line">15 7 5 4 9 2 1 6</span><br><span class="line">请输入各字符：(不需要空格分开，回车结束)        </span><br><span class="line">ILOVEYU                       &#x2F;&#x2F; U 后面有个空格</span><br><span class="line">请输入原字段,以#结束：</span><br><span class="line">I LOVE YOU#</span><br><span class="line">Huffman编码：</span><br><span class="line">100111100101110000111111001011111</span><br><span class="line">请输入Huffman编码,以#结束：</span><br><span class="line">100111100101110000111111001011111#</span><br><span class="line">原字段：</span><br><span class="line">I LOVE YOU</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>博客由 LAMP + WordPress 配置转移至 Github 与 Coding 托管方式双线部署</title>
    <url>/me/status-update/self-iteration/635.html</url>
    <content><![CDATA[<p>博客配置方式 与 域名 变化，随之也有想法的改变</p>
<a id="more"></a>

<h2 id="博客配置方式-与-域名-变化"><a href="#博客配置方式-与-域名-变化" class="headerlink" title="博客配置方式 与 域名 变化"></a>博客配置方式 与 域名 变化</h2><p>大一嫖到一个华为云的服务器，一时兴起配置了一个基于 LAMP + WordPress 的个人博客，有后端的个人博客可以实现许多功能，但是还是有些许麻烦</p>
<p>正好域名和服务器快到期了，就转移成了托管在 Github 和 Coding 的方式，原因是 Github 国内访问速度实在不堪，所以将境内外线路分别解析到 Coding 和 Github 的页面上，使用 hexo 平台可以很方便地将 markdown文件 渲染成静态网页</p>
<p>旧域名: <a href="https://www.wool.pub/">https://www.wool.pub</a> (大概还有俩月时间吧，不更新了)</p>
<p>新域名: <a href="https://www.woolym.com/">https://www.woolym.com</a> (里面所有文章都是由WordPress转移过来的，格式在细节上也许有问题…）</p>
<p>2020年，自己浪费了很多时间，博客也鸽了很久，准备重新捡起来，先写写数据结构课上的代码实现和理解吧</p>
<p>这是最近写的一篇 <a href="/algorithm/data-structure/633.html">线索二叉树的理解与实现</a></p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>状态更新</category>
        <category>自我迭代</category>
      </categories>
      <tags>
        <tag>自我迭代</tag>
        <tag>随笔</tag>
        <tag>状态更新</tag>
      </tags>
  </entry>
  <entry>
    <title>线索二叉树的理解与实现</title>
    <url>/algorithm/data-structure/633.html</url>
    <content><![CDATA[<p>线索二叉树 —— 利用二叉树二叉链结构中的空链域，储存某种遍历次序下每个带空链域的结点的前驱（后继）结点的指针</p>
<a id="more"></a>

<p><strong>数据结构课代码实现 之 中序线索二叉树</strong></p>
<h2 id="简要理解："><a href="#简要理解：" class="headerlink" title="简要理解："></a>简要理解：</h2><p>设p为二叉树中的一个结点</p>
<ol>
<li>若 <code>p-&gt;lchild</code> 为空 则储存中序遍历序列中 <code>p</code> 的前驱结点</li>
<li>若 <code>p-&gt;rchild</code> 为空 则储存中序遍历序列中 <code>p</code> 的后继结点</li>
</ol>
<p>那么在遍历二叉树线索化时需要一个标记来指明结点的 <code>lchild</code> 与 <code>rchild</code> 指向的是 线索指针 还是 孩子指针</p>
<p>线索化后可以不使用递归遍历，且可以正反向遍历</p>
<h2 id="具体理解-和-代码实现"><a href="#具体理解-和-代码实现" class="headerlink" title="具体理解 和 代码实现"></a>具体理解 和 代码实现</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span>Link, Thread&#125; PointerTag; <span class="comment">//枚举类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> // 线索二叉树比普通树多两个标记</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>   </span><br><span class="line">    PointerTag ltag; </span><br><span class="line">    PointerTag rtag; <span class="comment">// 用来标记每个结点的*lchild, *rchild指向的是 线索指针 还是 孩子指针</span></span><br><span class="line">&#125;BiThrNode, *BiThrTree;</span><br><span class="line"></span><br><span class="line">BiThrTree pre; <span class="comment">// 很关键的一个指针 用于线索化时储存上一个结点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">visit</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//visit函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="先序遍历递归建立二叉树"><a href="#先序遍历递归建立二叉树" class="headerlink" title="先序遍历递归建立二叉树"></a>先序遍历递归建立二叉树</h3><p>这里踩了个坑，一开始忘记把所有结点的 <code>ltag</code> 和 <code>rtag</code> 全部初始化为 <code>Link</code>，这会导致后面的 <code>InOrderThreading</code> 过程中产生错误</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CreateBiThrTree</span><span class="params">(BiThrTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ch; </span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">&#x27;#&#x27;</span>) T = <span class="literal">NULL</span>; <span class="comment">// 输入 # 号将当前结点设置为NULL</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(T = (BiThrNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiThrNode)))) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        T-&gt;data = ch;</span><br><span class="line">        T-&gt;ltag = Link;</span><br><span class="line">        T-&gt;rtag = Link;</span><br><span class="line">        CreateBiThrTree(T-&gt;lchild);</span><br><span class="line">        CreateBiThrTree(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线索化过程"><a href="#线索化过程" class="headerlink" title="线索化过程"></a>线索化过程</h3><p>线索化的过程就是将中序遍历的过程中的访问操作改为线索化过程</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(BiThrTree p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        InThreading(p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;lchild)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;ltag = Thread; </span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!pre-&gt;rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;rtag = Thread;</span><br><span class="line">            pre-&gt;rchild = p;   <span class="comment">//下文解释此处为何对pre指针进行操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;</span><br><span class="line">        InThreading(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历顺序相同 读取数据操作变为线索化过程</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InOrderThreading</span><span class="params">(BiThrTree &amp;Thrt,BiThrTree T)</span> <span class="comment">// 此处新创建一个线索树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(Thrt = (BiThrNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiThrNode)))) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    Thrt-&gt;ltag = Link;       <span class="comment">//创建 Thrt 的头结点</span></span><br><span class="line">    Thrt-&gt;rtag = Thread;     <span class="comment">//书上将 Thrt 的头结点的 ltag 设置为 Link, ltag 设置为 Link</span></span><br><span class="line">    Thrt-&gt;rchild = Thrt;     <span class="comment">//将 Thrt 头结点的 rchild 指向自己</span></span><br><span class="line">    <span class="keyword">if</span>(!T) Thrt-&gt;lchild = Thrt; <span class="comment">//如果 T 为空，则将 Thrt 头结点的 lchild 指向自己</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Thrt-&gt;lchild = T;</span><br><span class="line">        pre = Thrt;</span><br><span class="line">        InThreading(T);      <span class="comment">//此时 pre指针 指向了 T 中序遍历的最后一个结点</span></span><br><span class="line">        pre-&gt;rchild = Thrt;  <span class="comment">//将最后一个结点的后继指针指向 Thrt 的头结点 </span></span><br><span class="line">        pre-&gt;rtag = Thread;  <span class="comment">//更改最后一个结点 rchild 的类型</span></span><br><span class="line">        Thrt-&gt;rchild = pre;	 <span class="comment">//将 Thrt 的 rchild 指向最后一个结点 在倒中序遍历时有用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>InThreading</code> 中,遍历时，无法确认当前结点的后继结点，但是可以确定 <code>pre</code>结点 的后继结点(也就是当前结点)</p>
<p>在 <code>InOrderThreading</code> 中对 <code>Thrt</code> 的头结点 <code>ltag</code> 与 <code>rtag</code> 的设置貌似并没有多大意义，在这个程序中使用线索非递归化遍历时并没有检查这两个标记，也许在其他地方有用…</p>
<h3 id="中序非递归化遍历线索二叉树"><a href="#中序非递归化遍历线索二叉树" class="headerlink" title="中序非递归化遍历线索二叉树"></a>中序非递归化遍历线索二叉树</h3><h4 id="正向"><a href="#正向" class="headerlink" title="正向"></a>正向</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InOrderTraverse_Thr</span><span class="params">(BiThrTree T,<span class="keyword">bool</span> (* visit)(<span class="keyword">char</span> x))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiThrTree p = T-&gt;lchild;  <span class="comment">//指向二叉树的根结点</span></span><br><span class="line">    <span class="keyword">while</span>(p != T)             <span class="comment">//循环检测是否遍历结束 (最后一个结点的后继结点指向 T)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;ltag == Link) </span><br><span class="line">        	p = p-&gt;lchild;    <span class="comment">//循环直至到中序遍历的第一个结点</span></span><br><span class="line">		<span class="keyword">if</span>(!visit(p-&gt;data)) <span class="keyword">return</span> ERROR;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;rtag == Thread &amp;&amp; p-&gt;rchild != T)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;rchild;    <span class="comment">//通过后继结点遍历</span></span><br><span class="line">            visit(p-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;rchild;		  <span class="comment">//指向 p结点 的右孩子 (因为此时 p结点 的 rtag 为 Link)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="反向"><a href="#反向" class="headerlink" title="反向"></a>反向</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reInOrderTraverse_Thr</span><span class="params">(BiThrTree T,<span class="keyword">bool</span> (* visit)(<span class="keyword">char</span> x))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiThrTree p = T-&gt;rchild;   <span class="comment">//指向二叉树的根结点</span></span><br><span class="line">    <span class="keyword">while</span>(p != T)              <span class="comment">//循环检测是否遍历结束 (第一个结点的前驱结点指向 T)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;rtag == Link) </span><br><span class="line">            p = p-&gt;rchild;     <span class="comment">//循环直至到中序遍历的最后一个结点</span></span><br><span class="line">        <span class="keyword">if</span>(!visit(p-&gt;data)) <span class="keyword">return</span> ERROR;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;ltag == Thread &amp;&amp; p-&gt;lchild != T)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;lchild;     <span class="comment">//通过前驱结点遍历</span></span><br><span class="line">            visit(p-&gt;data); </span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;lchild;         <span class="comment">//同理还是指向 p结点 的左孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里还是比较好理解的</p>
<h3 id="递归化遍历方法"><a href="#递归化遍历方法" class="headerlink" title="递归化遍历方法"></a>递归化遍历方法</h3><p>为了验证，写一下递归化的遍历方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ooInThreading</span><span class="params">(BiThrTree p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    ooInThreading(p-&gt;lchild);</span><br><span class="line">    visit(p-&gt;data);</span><br><span class="line">    ooInThreading(p-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p>给出一组数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiThrTree Tre,Thre;</span><br><span class="line">    CreateBiThrTree(Tre);</span><br><span class="line">    ooInThreading(Tre);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    InOrderThreading(Thre, Tre);</span><br><span class="line">    InOrderTraverse_Thr(Thre, visit);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    reInOrderTraverse_Thr(Thre, visit);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输入： ABPL####CM##NO### */</span></span><br><span class="line"><span class="comment">/* 输出：L P B A M C O N 递归化</span></span><br><span class="line"><span class="comment">        L P B A M C O N 非递归线索化</span></span><br><span class="line"><span class="comment">        N O C M A B P L 反向非递归线索化 */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>哈哈</title>
    <url>/me/life/625.html</url>
    <content><![CDATA[<p>好臭 是什么腐烂了？</p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>整数划分问题</title>
    <url>/algorithm/basic-algorithm/622.html</url>
    <content><![CDATA[<p>整数划分问题思路简记</p>
<a id="more"></a>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>  将 m 个苹果放入 n 个盘子，问一共有几种放法（2，1，1与1，2，1被视为同一种放法）</li>
<li>  将整数 m 划分为若干个整数相加，问一共有几种分法（2，1，1与1，2，1被视为同一种分法）</li>
<li>  ········</li>
</ul>
<p>诸如此类问题，可以通过递归实现求解步骤</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>m 为划分数，n 称为最大划分数（划分出来的数字最大值）</p>
<p>递归过程中</p>
<ol>
<li> 当 m = 1 或者 n = 1 时，只有一种划分方法</li>
<li> 当 m &lt; n 时，相当于最大划分数为 m</li>
<li> 当 m = n 时，划分数中存在 n 的划分方法只有一种情况，所以为最大划分数为 n - 1 的分法数加一</li>
<li>当 m &gt; n 时（一般情况）可以分为两种情况<ul>
<li>  划分的数中不存在 n 这个数字，即最大划分数为 n - 1 的情况</li>
<li>  划分的数中存在 n 这个数字，则余下的数为 m - n，对 m - n 进行划分（递归实现）</li>
</ul>
</li>
</ol>
<p>放苹果也是同样的道理 m 为苹果数，n 为最大可放盘子数 递归过程中</p>
<ol>
<li> 当 m = 1 或者 n = 1 时，苹果或者盘子只有一个，只有一种划分方法</li>
<li> 当 m &lt; n 时，盘子比苹果多，忽略多余的盘子（砸碎）</li>
<li> 当 m = n 时，每个盘子只有一个苹果的情况只有一种放法，所以为一般情况下空一个盘子放法数加一</li>
<li>当 m &gt; n 时（一般情况）可以分为两种情况<ul>
<li>  先在 n 个盘子中放一个苹果，不留空盘子，然后再放余下的 m - n 个苹果</li>
<li>  空一个盘子，在 n - 1 个盘子里放 m 个苹果</li>
</ul>
</li>
</ol>
<h2 id="代码（采用了记忆化递归）"><a href="#代码（采用了记忆化递归）" class="headerlink" title="代码（采用了记忆化递归）"></a>代码（采用了记忆化递归）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">app</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[m][n])</span><br><span class="line">        <span class="keyword">return</span> a[m][n];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">1</span>  n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> a[m][n] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n &gt; m)</span><br><span class="line">            <span class="keyword">return</span> a[m][n] = app(m, m);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == m)</span><br><span class="line">            <span class="keyword">return</span> a[m][n] = app(m, n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> a[m][n] = app(m - n, n) + app(m, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图</title>
    <url>/algorithm/graph-theory/617.html</url>
    <content><![CDATA[<ul>
<li>  染色法判定二分图</li>
<li>  匈牙利算法求二分图最大匹配<a id="more"></a>
<h2 id="二分图概念"><a href="#二分图概念" class="headerlink" title="二分图概念"></a>二分图概念</h2></li>
</ul>
<p>可以将所有点分至两个集合，所有的边都存在于两个集合之间，集合内部不存在边（二分图中不含奇数环）</p>
<h2 id="染色法（二染色）判定二分图"><a href="#染色法（二染色）判定二分图" class="headerlink" title="染色法（二染色）判定二分图"></a>染色法（二染色）判定二分图</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>通过DFS或BFS实现 依次判断每个点是否被染过色，如果没有染过色则将其染色，并将与其相连的所有点通过DFS或BFS的方式染色，在染色的过程中如果出现冲突则证明不是二分图</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 染色过程</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[x] = color;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfs(j, <span class="number">3</span> - color))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (st[j] == color)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有点</span></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!st[i])</span><br><span class="line">        <span class="keyword">if</span> (!dfs(i, <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>给定一个二分图，求其最大匹配数（匹配成功为二分图中不存在两条边共用一个点，最大匹配数则是求满足上述条件最多有多少条边） 匈牙利算法具体思路为，选择一个集合，建立 match[N]（用于储存另一个集合匹配到所选集合中的哪一个点） 和 st[N] （用于标记第二个集合中的点在匹配过程中是否被遍历过） 遍历所选集合的所有点进行匹配操作，遍历过程中每次都要将 st 数组全部初始化为 false 匹配过程中要检查是否存在与其相连的另一个集合中的点可以匹配成功 检查过程大致为：如果一个点的 st 为 false，则标记为 true，并且检查其 match</p>
<ul>
<li>  如果match为 0，则更新 match 为当前被选集合中的点，返回匹配成功</li>
<li>  如果match不为 0，则使用递归的方式检查 match 储存的点是否还有其他可选择的与其相连的另一个集合中的点，如果存在则更新 match数组，并返回匹配成功</li>
</ul>
<p>如果检查所有的点都不满足匹配成功的条件则匹配失败</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, M = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n1, n2, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> st[N], match[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hungary</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span>  hungary(match[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n1, &amp;n2, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        add(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">if</span> (hungary(i))</span><br><span class="line">            res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树</title>
    <url>/algorithm/graph-theory/425.html</url>
    <content><![CDATA[<ul>
<li>  Prim求最小生成树</li>
<li>  Kruskal求最小生成树<a id="more"></a>
<h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2></li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>算法流程类似于Dijkstra，Prim是建立一个集合st[N]，将所有点（起点初始化为0）到该集合距离 dist 初始化为0x3f3f3f3f </p>
<p>n个点，一共遍历n次，每次寻找不在集合中距离集合最近的点（起点任意找），将其放入集合中，并用其更新其余所有点到集合的距离</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span>  dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line">        <span class="keyword">if</span> (dist[t] == <span class="number">0x3f3f3f3f</span>) <span class="comment">//如果距离集合最近的点与集合不连通，则不存在最小生成树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        res += dist[t]; <span class="comment">//这里记录的是最小生成树的边权之和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            dist[j] = min(dist[j], g[t][j]);</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol>
<li> 将所有边按照权重从小到大排序（快排）</li>
<li> 枚举每一条边，并检查边的起点与终点是否连通，如果不连通，则将这条边加入集合中（并查集）</li>
</ol>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    p[i] = i;</span><br><span class="line">sort(edge, edge + m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a = edge[i].a, b = edge[i].b, w = edge[i].w;</span><br><span class="line">    a = find(a), b = find(b);</span><br><span class="line">    <span class="keyword">if</span> (a == b)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p[a] = b;</span><br><span class="line">        cnt++;</span><br><span class="line">        res += w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cnt == n - <span class="number">1</span>) <span class="comment">//cnt记录边数, n 个点对应n - 1条边</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路问题</title>
    <url>/algorithm/graph-theory/420.html</url>
    <content><![CDATA[<ul>
<li><p>  Dijkstra求最短路</p>
</li>
<li><p>  Bellman-Ford求有边数限制的最短路</p>
</li>
<li><p>  SPFA求最短路</p>
</li>
<li><p>  Floyd求最短路</p>
<a id="more"></a>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2></li>
<li><p>单源最短路</p>
<ul>
<li>  边权为正 —— <a href="https://www.woolym.com/2020/02/05/512.html">Dijkstra</a></li>
<li>存在负权边<ul>
<li>  <a href="https://www.woolym.com/2020/02/06/514.html">Bellman-Ford</a></li>
<li>  <a href="https://www.woolym.com/2020/02/06/521.html">SPFA</a></li>
</ul>
</li>
</ul>
</li>
<li><p>  多源汇最短路 —— <a href="https://www.woolym.com/2020/02/06/528.html">Floyd</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>Floyd算法</title>
    <url>/algorithm/graph-theory/528.html</url>
    <content><![CDATA[<p>Floyd的浅要理解</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>三重循环，邻接矩阵 a[i][j] 最后的意义为 i 点到 j 点的最短路</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= n;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i][j] = min(a[i][j], a[i][k] + a[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>SPFA算法</title>
    <url>/algorithm/graph-theory/521.html</url>
    <content><![CDATA[<p>SPFA算法的浅要理解</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对Bellman-Ford进行优化，松弛操作的产生是因为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dist[b] = min(dist[b], dist[a] + w);</span><br></pre></td></tr></table></figure>
<p>dist[a] 在之前的松弛操作中发生了改变，导致 dist[b] 在该次松弛中也需要改变 所以可以使用队列的方式将因松弛发生改变的点放入队头 每次将队头弹出并将与之相连的点进行松弛操作，松弛成功后更新队头 直到队列为空 注：需要一个st[N]数组来记录哪些点已经在队列中，防止重复</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="增："><a href="#增：" class="headerlink" title="增："></a>增：</h2><p>SPFA判负环只需要添加一个 cnt[N] 数组，每次进行松弛操作时增加如下操作</p>
<p>cnt[j] = cnt[t] + 1; //cnt[j]代表从第1个点到第j个点经过了多少个点</p>
<p>当然一开始的队头需要将所有点都放入，因为负环可能不在1点开始的路径上 如果 cnt[j] &gt;= n 时，由于共n个点，抽屉原理可知存在负环</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">        q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= n)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>Bellman-Ford算法</title>
    <url>/algorithm/graph-theory/514.html</url>
    <content><![CDATA[<p>Bellman-Ford算法的浅要理解</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一般被用于求经过不超过k条边的最短路问题（需要一个备份数组防止连锁松弛，即一次迭代中因一次松弛导致另一个松弛） 也可用于判负环（一般用spfa），n个点，第n次更新如果发生更新，那证明存在负权回路 创建一个dist数组和一个backup数组，通过k次迭代 (含义为经过不超过k条边的最短路)，每一次迭代遍历所有边，进行松弛操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dist[b] = min(dist[b] + backup[a] + w);</span><br></pre></td></tr></table></figure>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, M = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dist[N], backup[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line">&#125; edge[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(backup, dist, <span class="keyword">sizeof</span> dist);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a = edge[j].a, b = edge[j].b, w = edge[j].w;</span><br><span class="line">            dist[b] = min(dist[b], backup[a] + w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="comment">// 假如不存在路径 dist[n]仍可能被更新得小一些</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        edge[i] = &#123;x, y, z&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t = bellman_ford();</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>Dijkstra算法</title>
    <url>/algorithm/graph-theory/512.html</url>
    <content><![CDATA[<p>Dijkstra算法的浅要理解</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>初始化距离数组 dist[N]，起点 dist[1] 为 0，其余所有点为0x3f3f3f3f 使用一个集合来存储已经确定最短路的点， 每次先找到一个不在集合中的 dist 最短的点 t，将其放入集合并用其更新其余所有点的 dist</p>
<p><code>dist[j] = min(dist[j], dist[t] + g[t][j]);</code></p>
<p>即可求出起点到点n的最短路</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="朴素版-O-n-2"><a href="#朴素版-O-n-2" class="headerlink" title="朴素版 O(n^2)"></a>朴素版 O(n^2)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[N][N], dist[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span>  dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + g[t][j])</span><br><span class="line">                dist[j] = dist[t] + g[t][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        g[a][b] = min(g[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dijkstra());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆优化版-O-mlogn"><a href="#堆优化版-O-mlogn" class="headerlink" title="堆优化版 O(mlogn)"></a>堆优化版 O(mlogn)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N], e[N], ne[N], idx, w[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++idx] = y;</span><br><span class="line">    ne[idx] = h[x];</span><br><span class="line">    h[x] = idx;</span><br><span class="line">    w[idx] = z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;PII, <span class="built_in">vector</span>&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.push(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (heap.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.top();</span><br><span class="line">        heap.pop();</span><br><span class="line">        <span class="keyword">int</span> distance = t.first, ver = t.second;</span><br><span class="line">        <span class="keyword">if</span> (st[ver])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.push(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        add(x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dijkstra() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>有向图的拓扑排序</title>
    <url>/algorithm/graph-theory/502.html</url>
    <content><![CDATA[<p>拓扑排序的简要理解</p>
<a id="more"></a>
<h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><p>拓扑排序只存在于有向无环图，排序后的序列满足对于图中任意一条边的起点在序列中一定在终点前（拓扑排序的序列不唯一）</p>
<h2 id="实现方法："><a href="#实现方法：" class="headerlink" title="实现方法："></a>实现方法：</h2><p>BFS的方法实现，纪录每一个点的入度（作为几条边的终点），首先将入度为0的点入队（入度为0意味着该点之前的点已经被排入序列），然后开始BFS的过程，重复队头出队，将队头相连的点的入度减一，并检查更新后的入度是否为0，如果为0则将其扩展至队头的过程 (数组实现队列的话，数组则保存了拓扑序列，如果使用queue则需要使用另外的数组保存序列)</p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N], e[N], ne[N], idx, d[N], q[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">topo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[i] == <span class="number">0</span>)</span><br><span class="line">            q[++tt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            d[j]--;</span><br><span class="line">            <span class="keyword">if</span> (d[j] == <span class="number">0</span>)</span><br><span class="line">                q[++tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        e[++idx] = y;</span><br><span class="line">        ne[idx] = h[x];</span><br><span class="line">        h[x] = idx;</span><br><span class="line">        d[y]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (topo())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>把自己的心包在琥珀里吧</title>
    <url>/me/life/496.html</url>
    <content><![CDATA[<a id="more"></a>
<p>时间太少了，不允许你继续这样子沉浸在那里了<br>要怪只能怪你了，做的事情伤害了自己<br>呼吸的频率不能被打乱<br>被划破嗓子的时候，请你回来看看这些文字吧<br>Goodnight ymz.</p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>BFS经典问题</title>
    <url>/algorithm/graph-theory/473.html</url>
    <content><![CDATA[<ul>
<li>  八数码问题题解</li>
<li>  图中点的层次问题题解<a id="more"></a>
<h2 id="八数码问题："><a href="#八数码问题：" class="headerlink" title="八数码问题："></a>八数码问题：</h2></li>
</ul>
<p><a href="https://www.acwing.com/problem/content/847/">https://www.acwing.com/problem/content/847/</a></p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>题目使用了一个数组来存矩阵 例：1 2 3 4 5 6 7 8 x 表示</p>
<p>1 2 3<br>4 5 6<br>7 8 x</p>
<p>可以将每一种矩阵状态看做一个点，用c11的unordered_map将距离与每个状态对应，使用BFS遍历求最短路 需要思考的问题：如何实现一个状态到其他状态的转移</p>
<h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> End = <span class="string">&quot;12345678x&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="built_in">string</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line">    q.push(start);</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; d;</span><br><span class="line">    d[start] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span> (t == End)</span><br><span class="line">            <span class="keyword">return</span> d[t];</span><br><span class="line">        <span class="keyword">int</span> dis = d[t];</span><br><span class="line">        <span class="keyword">int</span> k = t.find(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">        <span class="keyword">int</span> y = k / <span class="number">3</span>, x = k % <span class="number">3</span>;       <span class="comment">//将当前状态的 x 的坐标表示出来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x1 = x + dx[i], y1 = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (x1 &gt;= <span class="number">0</span> &amp;&amp; x1 &lt; <span class="number">3</span> &amp;&amp; y1 &gt;= <span class="number">0</span> &amp;&amp; y1 &lt; <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(t[k], t[x1 + y1 * <span class="number">3</span>]);</span><br><span class="line">                <span class="keyword">if</span> (!d.count(t))</span><br><span class="line">                &#123;</span><br><span class="line">                    d[t] = dis + <span class="number">1</span>;</span><br><span class="line">                    q.push(t);</span><br><span class="line">                &#125;</span><br><span class="line">                swap(t[k], t[x1 + y1 * <span class="number">3</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> start;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">        start += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; bfs(start) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图中点的层次-："><a href="#图中点的层次-：" class="headerlink" title="图中点的层次 ："></a>图中点的层次 ：</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>给定一个n个点m条边的有向图，图中可能存在重边和自环。所有边的长度都是1，点的编号为1~n。 请你求出1号点到n号点的最短距离，如果从1号点无法走到n号点，输出-1。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数n和m。 接下来m行，每行包含两个整数a和b，表示存在一条从a走到b的长度为1的边。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示1号点到n号点的最短距离。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 ≤ n, m ≤ 1e5</p>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>裸题，可以将1号点放入队头开始BFS的过程，每次扩展队头时记录 dis 数组记录1号点到当前点的距离(1号点距离初始化为0)，注意该题所有边的长度都是1，所以可以使用BFS求最短路</p>
<h3 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N], e[N], ne[N], idx, dis[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;     <span class="comment">//1号点距离初始化为0</span></span><br><span class="line">    q.push(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dis[j] == <span class="number">-1</span>)        <span class="comment">//判断j点是否扩展过（自环、重边）</span></span><br><span class="line">            &#123;</span><br><span class="line">                dis[j] = dis[t] + <span class="number">1</span>;</span><br><span class="line">                q.push(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">-1</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        add(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; bfs() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>DFS经典问题</title>
    <url>/algorithm/graph-theory/470.html</url>
    <content><![CDATA[<ul>
<li>  n-皇后问题题解</li>
<li>  树的重心问题题解<a id="more"></a>
<h2 id="n-皇后问题："><a href="#n-皇后问题：" class="headerlink" title="n-皇后问题："></a>n-皇后问题：</h2></li>
</ul>
<h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>n-皇后问题是指将 n 个皇后放在 n∗n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。现在给定整数n，请你输出所有的满足条件的棋子摆法。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>共一行，包含整数n。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>每个解决方案占n行，每行输出一个长度为n的字符串，用来表示完整的棋盘状态。 其中”.”表示某一个位置的方格状态为空，”Q”表示某一个位置的方格上摆着皇后。 每个方案输出完成后，输出一个空行。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 ≤ n ≤ 9</p>
<h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><h4 id="思路一：按行遍历-O-n"><a href="#思路一：按行遍历-O-n" class="headerlink" title="思路一：按行遍历 O(n!)"></a>思路一：按行遍历 O(n!)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;<span class="comment">// N开20是因为对角线有2N - 1条</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> col[N], dg[N], udg[N];<span class="comment">//列 对角线 反对角线</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(g[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!col[i] &amp;&amp; !dg[x + i] &amp;&amp; !udg[x - i + n]) <span class="comment">//x - i + n 给反对角线加偏移量，防止小于0</span></span><br><span class="line">        &#123;</span><br><span class="line">            g[x][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            col[i] = dg[x + i] = udg[x - i + n] = <span class="literal">true</span>;</span><br><span class="line">            dfs(x + <span class="number">1</span>);</span><br><span class="line">            g[x][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            col[i] = dg[x + i] = udg[x - i + n] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路二：按元素遍历-O-2的n平方次方"><a href="#思路二：按元素遍历-O-2的n平方次方" class="headerlink" title="思路二：按元素遍历 O(2的n平方次方)"></a>思路二：按元素遍历 O(2的n平方次方)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> col[N], dg[N], udg[N], row[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> s)</span> <span class="comment">// s为已经放上去的皇后数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y == n)</span><br><span class="line">    &#123;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(g[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(x, y + <span class="number">1</span>, s);</span><br><span class="line">    <span class="keyword">if</span> (!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x + y] &amp;&amp; !udg[x - y + n])</span><br><span class="line">    &#123;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="literal">true</span>;</span><br><span class="line">        dfs(x, y + <span class="number">1</span>, s + <span class="number">1</span>);</span><br><span class="line">        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="literal">false</span>;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树的重心："><a href="#树的重心：" class="headerlink" title="树的重心："></a>树的重心：</h2><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><p>给定一颗树，树中包含n个结点（编号1~n）和n-1条无向边。请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。 重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。</p>
<h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数n，表示树的结点数。 接下来n-1行，每行包含两个整数a和b，表示点a和点b之间存在一条边。</p>
<h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数m，表示重心的所有的子树中最大的子树的结点数目。</p>
<h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤ n ≤ 1e5</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>可以在DFS的过程中创建一个数组将每一个点作为根节点的树的元素的数量和 sum 求出，然后在每一次求 sum 值时求出去掉该点后所有连通块的元素数量的最大值 res（所有子树的元素数量与该点父节点所在的连通块元素数量大小(总元素数 - sum)进行比较），然后再与答案 ans 进行比较，求出最小值</p>
<h3 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">2</span> * N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N], ne[M], e[M], idx; <span class="comment">//无向图加边加两条开双倍大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = N, n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span>               <span class="comment">//以点u为根节点的子树的大小</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, sum = <span class="number">1</span>;    <span class="comment">//u点也属于该子树，所以sum初始值为1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> s = dfs(j);</span><br><span class="line">            sum += s;</span><br><span class="line">            res = max(res, s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res = max(res, n - sum);</span><br><span class="line">    ans = min(res, ans);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        add(a, b), add(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>DFS（深度优先遍历） 与 BFS（广度优先遍历）</title>
    <url>/algorithm/graph-theory/458.html</url>
    <content><![CDATA[<p>DFS 与 BFS 的思想</p>
<a id="more"></a>
<p>以遍历树为例</p>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>使用了栈思想 <img src="https://www.woolym.com/images/dfs-bfs/dfs.gif"></p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><ul>
<li>  将根节点入栈</li>
<li>  检查与栈顶元素相连的元素是否存在未被遍历(标记)过的元素，如果有则将其入栈，如果无则将堆顶元素弹出</li>
<li>  重复第二步直到遍历结束</li>
</ul>
<h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// st[u] 表示点u已经被遍历过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) dfs(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>使用了队列的实现方式 <img src="https://www.woolym.com/images/dfs-bfs/bfs.gif"></p>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><ul>
<li>  将根节点入队</li>
<li>  弹出队头并将与队头节点相连的未遍历过的节点依次入队</li>
<li>  重复第二步直到遍历结束(队列为空)</li>
</ul>
<h3 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">q.push(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q.size())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> t = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!s[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">            q.push(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/algorithm/data-structure/446.html</url>
    <content><![CDATA[<p>数字哈希 与 字符串前缀哈希法</p>
<a id="more"></a>
<p>哈希表主要作用为将一个较大的空间映射到一个较小的空间</p>
<h2 id="一、数字哈希"><a href="#一、数字哈希" class="headerlink" title="一、数字哈希"></a>一、数字哈希</h2><p>将一些值域区间大的数字映射到一个较小的区间，一般将每个数字进行取模运算，模一般为一个离2的整次幂较远的一个质数(这样取可以减少冲突)，例:0—1e9 映射到 0—1e5，我们可以模1e5+3这个数字，（但是数组就得开得大于这个数字了） 有两种避免冲突的方法，分别为 拉链法 与 开放寻址法</p>
<h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><p>运用了邻接表的思想，将每次取模操作的结果作为相应的数组地址，将原数字储存于该数组地址的链表上，每次查找时则遍历取模操作结果的数组地址上的链表，来检查是否存在该数字</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = (x % p + N) % N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> t = (x % p + N) % N; <span class="comment">//p为模</span></span><br><span class="line">e[++idx] = x;</span><br><span class="line">ne[idx] = h[t];</span><br><span class="line">h[t] = idx;</span><br></pre></td></tr></table></figure>
<h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>一般将数组开为映射后区间大小的两倍，模的选择方法同拉链法，一般取小于映射区间的一个最大的质数，开放寻址法具体思路核心是首先将数组元素初始化为一个不存在于源区间值域的数字，(例如0x3f3f3f3f)，检查一个数x的取模操作的结果对应的数组地址上储存的元素如果同时满足不等于初始化元素并且不等于x，则继续检查下一个地址，如果检查到映射区间的最大地址时返回到第一个地址，直到不满足上述条件，则返回当前地址，如果x存在于哈希表，则该地址为x的地址，如果x不存在，则当前地址为x应当储存的地址</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="查找操作-1"><a href="#查找操作-1" class="headerlink" title="查找操作"></a>查找操作</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = (x % p + N) % N; <span class="comment">//p为模</span></span><br><span class="line">    <span class="keyword">while</span> (a[t] != null &amp;&amp; a[t] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == N)</span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">        t++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">k = find(x);</span><br><span class="line">a[k] = x;</span><br></pre></td></tr></table></figure>
<h2 id="二、字符串前缀哈希法"><a href="#二、字符串前缀哈希法" class="headerlink" title="二、字符串前缀哈希法"></a>二、字符串前缀哈希法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>通过将字符串看作一个p进制的数字，求出字符串的值对一个数字q取模得到的值作为前缀哈希数组的值，来求出整个前缀哈希数组的方式 注：</p>
<ul>
<li>  假设人品足够好不产生冲突的情况</li>
<li>  p一般取131或者13331，q取2^64，这样一般不会出现冲突，并且使用 unsigned long long 定义前缀数组则可通过溢出的方式免去取模的步骤</li>
</ul>
<p>我们通过上述方法也可求出一个字符串任意子段的哈希值，公式为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a[r] - a[l - <span class="number">1</span>] * p ^ (r - l + <span class="number">1</span>) <span class="comment">// 自己理解</span></span><br></pre></td></tr></table></figure>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="建立字符串前缀哈希数组"><a href="#建立字符串前缀哈希数组" class="headerlink" title="建立字符串前缀哈希数组"></a>建立字符串前缀哈希数组</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123; </span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] * P;          <span class="comment">// 简化求子段哈希</span></span><br><span class="line">    a[i] = a[i - <span class="number">1</span>] * P + str[i]; <span class="comment">// a为前缀数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="求子段哈希"><a href="#求子段哈希" class="headerlink" title="求子段哈希"></a>求子段哈希</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a[r] - a[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>堆（Heap）</title>
    <url>/algorithm/data-structure/442.html</url>
    <content><![CDATA[<p>通常看为一棵完全二叉树的数组对象</p>
<a id="more"></a>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="分为-大顶堆-与-小顶堆-两种"><a href="#分为-大顶堆-与-小顶堆-两种" class="headerlink" title="分为 大顶堆 与 小顶堆 两种"></a>分为 大顶堆 与 小顶堆 两种</h3><p>大顶堆满足 <code>h[i] &gt; h[2 * i] &amp;&amp; h[i] &gt; h[2 * i + 1]</code></p>
<p>小顶堆满足 <code>h[i] &gt; h[2 * i] &amp;&amp; h[i] &gt; h[2 * i + 1]</code></p>
<p>建堆时对从第 <code>n/2</code> 个数到第 <code>1</code> 个数进行 <code>down</code> 操作即可 最差的时间复杂度为 O(nlogn)</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="down操作"><a href="#down操作" class="headerlink" title="down操作"></a><code>down</code>操作</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = x;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * x &lt;= sz &amp;&amp; h[t] &gt; h[<span class="number">2</span> * x])</span><br><span class="line">        t = <span class="number">2</span> * x;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * x + <span class="number">1</span> &lt;= sz &amp;&amp; h[t] &gt; h[<span class="number">2</span> * x + <span class="number">1</span>])</span><br><span class="line">        t = <span class="number">2</span> * x + <span class="number">1</span>;</span><br><span class="line">    swap(h[t], h[x]);</span><br><span class="line">    <span class="keyword">if</span> (x != t)</span><br><span class="line">        down(t);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="up操作"><a href="#up操作" class="headerlink" title="up操作"></a><code>up</code>操作</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = x;</span><br><span class="line">    <span class="keyword">if</span> (x / <span class="number">2</span> &gt;= <span class="number">1</span> &amp;&amp; h[t] &lt; h[x / <span class="number">2</span>])</span><br><span class="line">        t = x / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (t != x)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(h[t], h[x]);</span><br><span class="line">        up(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除某个元素"><a href="#删除某个元素" class="headerlink" title="删除某个元素"></a>删除某个元素</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">swap(h[x], h[sz]);</span><br><span class="line">sz--;</span><br><span class="line">down(x);</span><br><span class="line">up(x);</span><br></pre></td></tr></table></figure>
<ol>
<li> 删除堆顶后只需要 down 一次</li>
<li> 如果想要实现删除或者更改第 k 个插入的元素则需要创建额外的两个数组建立映射，同时在 down 与 up 操作中进行映射的维护</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>JOJO</title>
    <url>/me/anime/436.html</url>
    <content><![CDATA[<blockquote>
<p>人类的赞歌是勇气的赞歌，人类的伟大是勇气的伟大</p>
</blockquote>
<p>你的下一句话是 「 寒假摸鱼真爽 」</p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>Anime</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>Anime</tag>
      </tags>
  </entry>
  <entry>
    <title>01分数规划 与 最优比例生成树</title>
    <url>/algorithm/graph-theory/429.html</url>
    <content><![CDATA[<p>寒假更新</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树</title>
    <url>/algorithm/data-structure/418.html</url>
    <content><![CDATA[<p>寒假更新</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Trie字典树</title>
    <url>/algorithm/data-structure/398.html</url>
    <content><![CDATA[<p>Trie树的实现方法与性质</p>
<a id="more"></a>
<p>Trie树 （字典树）可以高效统计、排序、保存大量字符串</p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">0</span>, cnt[N], son[N][<span class="number">26</span>]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;     <span class="comment">//本例所有字符串为小写字母串</span></span><br><span class="line">        <span class="keyword">if</span> (!son[p][u])</span><br><span class="line">            son[p][u] = ++idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;                      <span class="comment">//cnt记录该串出现的次数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt[p] &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> a[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, a, str);</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            insert(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            query(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h2><ul>
<li>  根节点没有字符，除根节点外的所有节点只保存一个字符</li>
<li>  从根节点到某一节点，路径上的所有字符连接起来为该节点所对应的字符串</li>
<li>  每个节点的所有子节点的字符各不相同</li>
</ul>
<h2 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h2><h3 id="最大异或对"><a href="#最大异或对" class="headerlink" title="最大异或对"></a>最大异或对</h3><p>n个数中任意两个数进行异或操作，求所有异或对中最大的异或对</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">31</span> * N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], son[M][<span class="number">2</span>], idx = <span class="number">0</span>, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = x &gt;&gt; i &amp; <span class="number">1</span>;      <span class="comment">//常用位运算操作，查询一个二进制数的第k位（右至左）</span></span><br><span class="line">        <span class="keyword">if</span> (!son[p][u])</span><br><span class="line">            son[p][u] = ++idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (son[p][!u])</span><br><span class="line">        &#123;</span><br><span class="line">            p = son[p][!u];    </span><br><span class="line">            res = res * <span class="number">2</span> + !u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = son[p][u];</span><br><span class="line">            res = res * <span class="number">2</span> + u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(a[i]);           <span class="comment">//只需要边查询边插入，每次遍历只需要查询第i个之前的数字</span></span><br><span class="line">        res = max(res, query(a[i]) ^ a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>暴力需要进行两重循环，我们优化第二重循环 用Trie树储存数字，每次查询时遵循从高位开始尽量选择与当前第i个数字对应位置不同的数字（异或异1同0），循环31次即可确定出一个与当前第i个数字异或的最大的数字，然后与之前的答案进行max操作</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉筛法（线性筛）</title>
    <url>/algorithm/number-theory/387.html</url>
    <content><![CDATA[<p>求n以内质数，只用最小质因子筛掉n以内的所有合数</p>
<a id="more"></a>
<p>首先合数都能表示成都能表示成若干质数的积，所以每个合数都有一个最小质因子，我们只用每个合数的最小值因子来筛去合数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e8</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> primes[N], n, cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!primes[i])</span><br><span class="line">            primes[++cnt] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; i * primes[j] &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            primes[i * primes[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; primes[j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><ol>
<li> <code>i % primes[j] == 0</code> 时，<code>primes[j]</code> 是 <code>i</code> 的最小质因子，所以 <code>primes[j]</code> 也是 <code>i * primes[j]</code> 的最小质因子</li>
<li> <code>i % primes[j] != 0</code> 时 ，<code>primes[j]</code> 小于 <code>i</code> 的所有质因子，所以 <code>primes[j]</code> 也是 <code>i * primes[j]</code> 的最小质因子</li>
<li> 对于任意合数 <code>x</code> ，假设 <code>primes[j]</code> 为 <code>x</code> 的最小值因子，当枚举到 <code>x / primes[j]</code> 时 <code>x</code> 会被筛去</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>埃氏筛法（埃拉托斯特尼筛法）</title>
    <url>/algorithm/number-theory/378.html</url>
    <content><![CDATA[<p>求n以内质数，筛掉不大于根号n的所有质数的倍数（合数）</p>
<a id="more"></a>
<p>《算法竞赛 入门到进阶》给的模板 ：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, cnt = <span class="number">0</span>, primes[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt;= n; j += i) <span class="comment">//优化为i^2 以5为例5*2 5*3 5*4已经在i=2和3时筛掉了</span></span><br><span class="line">                st[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[++cnt] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>合并一下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, cnt = <span class="number">0</span>, primes[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[++cnt]=i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> j = (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>)i * (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>)i; j &lt;= n; j += i)</span><br><span class="line">                st[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(nloglogn)</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP字符串</title>
    <url>/algorithm/data-structure/338.html</url>
    <content><![CDATA[<p>KMP字符串问题的思想</p>
<a id="more"></a>
<p>给定一个模式串S，以及一个模板串P，所有字符串中只包含大小写英文字母以及阿拉伯数字，模板串P在模式串S中多次作为子串出现，求出模板串P在模式串S中所有出现的位置的起始下标。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入整数N，表示字符串P的长度。 第二行输入字符串P。 第三行输入整数M，表示字符串S的长度。 第四行输入字符串S。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，输出所有出现位置的起始下标（下标从0开始计数），整数之间用空格隔开。</p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>, M = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> p[N], s[M];</span><br><span class="line"><span class="keyword">int</span> ne[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p + <span class="number">1</span> &gt;&gt; m &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; p[j + <span class="number">1</span>] != p[i])</span><br><span class="line">            j = ne[j];</span><br><span class="line">        <span class="keyword">if</span> (p[j + <span class="number">1</span>] == p[i])</span><br><span class="line">            j++;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; p[j + <span class="number">1</span>] != s[i])</span><br><span class="line">            j = ne[j];</span><br><span class="line">        <span class="keyword">if</span> (p[j + <span class="number">1</span>] == s[i])</span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span> (j == n)</span><br><span class="line">        &#123;</span><br><span class="line">            j = ne[j];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i - n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h2><p>我们可以从暴力入手</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>, M = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> p[N], s[M];</span><br><span class="line"><span class="keyword">int</span> ne[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p + <span class="number">1</span> &gt;&gt; m &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i + j - <span class="number">1</span>] != p[j])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i - <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，在进行比较时，上一次比较时的信息可以用来优化这次模板串的移动 即转换成模板串最少往后移动多少位的问题 需要预处理模板串，计算出模板串每一位作为后缀子串的终点，与该后缀子串相等的前缀子串最大长度为多少 我们可以创建一个next数组来储存（关键） ne[i]表示以i点为后缀子串终点，相等的前缀子串的最大长度 next数组的创建 和 模式串与模板串的比较过程 的具体实现方法为双指针算法（举例体会）</p>
<h3 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h3><ul>
<li>  在两串比较成功一次后，需要一个 j = ne[j]; 的操作，是为了在比对模式串的下一位时模板串移动最少的位数</li>
<li>  在创建next数组时 i 从2开始，ne[1] = 0</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟队列 与 单调队列</title>
    <url>/algorithm/data-structure/322.html</url>
    <content><![CDATA[<p>使用数组实现队列与单调队列的功能</p>
<a id="more"></a>
<p>qu[N]为队列数组 tt为队尾指针，hh为队头指针 (队头队尾指针初始化为0)</p>
<h2 id="1-模拟队列"><a href="#1-模拟队列" class="headerlink" title="1.模拟队列"></a>1.模拟队列</h2><h3 id="向队尾插入一个元素（push）"><a href="#向队尾插入一个元素（push）" class="headerlink" title="向队尾插入一个元素（push）"></a>向队尾插入一个元素（push）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">qu[++tt] = x;</span><br></pre></td></tr></table></figure>
<h3 id="返回队头元素（front）"><a href="#返回队头元素（front）" class="headerlink" title="返回队头元素（front）"></a>返回队头元素（front）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; qu[hh + <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<h3 id="弹出队头元素（pop）"><a href="#弹出队头元素（pop）" class="headerlink" title="弹出队头元素（pop）"></a>弹出队头元素（pop）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">hh++;</span><br></pre></td></tr></table></figure>
<h3 id="返回队列大小（size）"><a href="#返回队列大小（size）" class="headerlink" title="返回队列大小（size）"></a>返回队列大小（size）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; tt - hh;</span><br></pre></td></tr></table></figure>
<h3 id="检查队列是否为空（empty）"><a href="#检查队列是否为空（empty）" class="headerlink" title="检查队列是否为空（empty）"></a>检查队列是否为空（empty）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (tt - hh)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NO&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;YES&quot;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="2-单调队列-（滑动窗口问题）"><a href="#2-单调队列-（滑动窗口问题）" class="headerlink" title="2.单调队列 （滑动窗口问题）"></a>2.单调队列 （滑动窗口问题）</h2><p>给定一个数组，有一个大小为k的滑动窗口，它从数组的最左边移动到最右边，您只能在窗口中看到k个数字，每次滑动窗口向右移动一个位置。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入包含两行。 第一行包含两个整数n和k，分别代表数组长度和滑动窗口的长度。 第二行有n个整数，代表数组的具体数值。 同行数据之间用空格隔开。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出包含两个。 第一行输出，从左至右，每个位置滑动窗口中的最小值。 第二行输出，从左至右，每个位置滑动窗口中的最大值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], q[N], tt = <span class="number">-1</span>, hh = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + <span class="number">1</span>)</span><br><span class="line">            hh++;</span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i])</span><br><span class="line">            tt--;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; a[q[hh]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    tt = <span class="number">-1</span>, hh = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + <span class="number">1</span>)</span><br><span class="line">            hh++;</span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i])</span><br><span class="line">            tt--;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; a[q[hh]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h3><p>具体思想类似于单调栈，维护大小为窗口大小的一个队列，以求窗口最小值为例，按序检查每一个数字，如果当前队尾元素大于等于当前元素则弹出队尾元素并且检查新的队尾元素，直到队尾元素小于当前数或者队列无元素，之后把当前数插入队尾，求窗口最大值同理 (队列元素具有严格单调性)</p>
<h3 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h3><ul>
<li>  q数组储存的是元素地址</li>
<li>  循环至第k个元素开始输出</li>
<li>  要检查队头元素是否滑出窗口，如果滑出则须hh++;</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟栈 与 单调栈</title>
    <url>/algorithm/data-structure/320.html</url>
    <content><![CDATA[<p>使用数组实现栈与单调栈的功能</p>
<a id="more"></a>
<p>st[N]作为栈数组，tt作为栈顶指针 (初始为0)</p>
<h2 id="一、模拟栈"><a href="#一、模拟栈" class="headerlink" title="一、模拟栈"></a>一、模拟栈</h2><h3 id="向栈顶插入一个元素（push）"><a href="#向栈顶插入一个元素（push）" class="headerlink" title="向栈顶插入一个元素（push）"></a>向栈顶插入一个元素（push）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">st[++tt] = x;</span><br></pre></td></tr></table></figure>
<h3 id="弹出栈顶元素（pop）"><a href="#弹出栈顶元素（pop）" class="headerlink" title="弹出栈顶元素（pop）"></a>弹出栈顶元素（pop）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tt--;</span><br></pre></td></tr></table></figure>
<h3 id="查询栈是否为空（empty）"><a href="#查询栈是否为空（empty）" class="headerlink" title="查询栈是否为空（empty）"></a>查询栈是否为空（empty）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!tt)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;YES&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NO&quot;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="返回栈的大小（size）"><a href="#返回栈的大小（size）" class="headerlink" title="返回栈的大小（size）"></a>返回栈的大小（size）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; tt;</span><br></pre></td></tr></table></figure>
<h3 id="返回栈顶元素（top）"><a href="#返回栈顶元素（top）" class="headerlink" title="返回栈顶元素（top）"></a>返回栈顶元素（top）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; st[tt];</span><br></pre></td></tr></table></figure>
<h2 id="二、单调栈"><a href="#二、单调栈" class="headerlink" title="二、单调栈"></a>二、单调栈</h2><p>给定一个长度为N的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出-1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> st[N], tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        <span class="keyword">while</span> (tt &amp;&amp; st[tt] &gt;= x)</span><br><span class="line">            tt--;</span><br><span class="line">        <span class="keyword">if</span> (tt)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; st[tt];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">        st[++tt] = x;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h3><p>按序检查每一个数，如果当前栈顶元素大于等于当前数则弹出当前栈顶元素并且继续检查新的栈顶元素，直到栈顶元素小于当前数或者栈中无元素 ，检查栈的大小不为零后输出栈顶元素，并且把当前数入栈 (最后栈中元素严格单调递增)</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>双链表</title>
    <url>/algorithm/data-structure/299.html</url>
    <content><![CDATA[<p>数组实现双链表</p>
<a id="more"></a>
<p>e[N]储存每个节点的value l[N]储存每个节点的左指针 r[N]储存每个节点的右指针 idx保存已使用到的地址</p>
<h2 id="初始化操作"><a href="#初始化操作" class="headerlink" title="初始化操作"></a>初始化操作</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在这里将双链表的头节点地址表示为0，尾节点地址表示为1，0与1使用所以这里的idx初始化为2</span></span><br></pre></td></tr></table></figure>
<h2 id="在地址为k的节点右边（后边）增加一个节点"><a href="#在地址为k的节点右边（后边）增加一个节点" class="headerlink" title="在地址为k的节点右边（后边）增加一个节点"></a>在地址为k的节点右边（后边）增加一个节点</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[idx] = k;</span><br><span class="line">    r[idx] = r[k];</span><br><span class="line">    l[r[k]] = idx;</span><br><span class="line">    r[k] = idx;</span><br><span class="line">    e[idx++] = x;</span><br><span class="line">&#125;<span class="comment">//在这里r[k]的更新一定要在 l[r[k]]更新后</span></span><br></pre></td></tr></table></figure>
<p>（代码实现往右增加，同样可以实现往左，但往左边增加相当于往左边节点的右边增加节点）</p>
<h2 id="删除地址为k的节点"><a href="#删除地址为k的节点" class="headerlink" title="删除地址为k的节点"></a>删除地址为k的节点</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>单链表</title>
    <url>/algorithm/data-structure/297.html</url>
    <content><![CDATA[<p>数组实现单链表</p>
<a id="more"></a>
<p>e[N]储存每个节点的value，ne[N]储存每个节点的next指针 变量head储存头节点，idx储存当前使用到的地址</p>
<h2 id="初始化操作"><a href="#初始化操作" class="headerlink" title="初始化操作"></a>初始化操作</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在头节点后增加一个节点"><a href="#在头节点后增加一个节点" class="headerlink" title="在头节点后增加一个节点"></a>在头节点后增加一个节点</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">headadd</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = head;</span><br><span class="line">    head = idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在地址为k的节点后增加一个节点"><a href="#在地址为k的节点后增加一个节点" class="headerlink" title="在地址为k的节点后增加一个节点"></a>在地址为k的节点后增加一个节点</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = ne[k];</span><br><span class="line">    ne[k] = idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除地址为k的节点"><a href="#删除地址为k的节点" class="headerlink" title="删除地址为k的节点"></a>删除地址为k的节点</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>区间合并问题</title>
    <url>/algorithm/basic-algorithm/295.html</url>
    <content><![CDATA[<p>区间合并问题思路</p>
<a id="more"></a>
<p>已知若干闭区间，将其中存在重复的区间合并的方法（一个区间右端点与另一个区间的左端点重合也视为重复） 例：[2,4]、[4,7]、[7,10]、[8,9]、[8,15]、[17,21]进行区间合并 结果应为[2,15]、[17,21]两个区间 我们可以将所有区间按照左端点进行排序（从小到大） 之后从第一个区间开始维护 第二个区间与第一个区间有如下几种关系：//称区间左端点为st 右端点为ed</p>
<ul>
<li>  st1&lt;st2&lt;ed2&lt;ed1</li>
<li>  st1&lt;st2&lt;ed1&lt;ed2</li>
<li>  st1&lt;ed1=st2&lt;ed2</li>
<li>  st1&lt;ed1&lt;st2&lt;ed2</li>
</ul>
<p>在遍历区间时，前三种情况只需要不断更新维护区间的ed 第四种情况我们需要将当前维护的区间放入记录容器中，更新维护区间的st，ed为新的st与ed c++代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;PII&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;PII&gt; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;PII&gt; res;</span><br><span class="line">    <span class="keyword">int</span> st = a[<span class="number">0</span>].first, ed = a[<span class="number">0</span>].second;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; item.first)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(&#123;st, ed&#125;);</span><br><span class="line">            st = item.first;</span><br><span class="line">        &#125;</span><br><span class="line">        ed = max(ed, item.second);</span><br><span class="line">    &#125;</span><br><span class="line">    res.push_back(&#123;st, ed&#125;);</span><br><span class="line">    <span class="keyword">return</span> res.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>离散化</title>
    <url>/algorithm/basic-algorithm/268.html</url>
    <content><![CDATA[<p>关于离散化算法的理解</p>
<a id="more"></a>
<p>给定一个值域(1e9)很大，个数不多(1e5)的数列 如何以这些值为下标来实现某些算法呢？<br>可以将这些数排序后映射到从0或1开始的自然数 称为 <strong><em>离散化</em></strong><br>实现离散化有两个关键步骤： </p>
<ol>
<li>这些数字中有重复需要 去重 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sort(a.begin(), a.end());</span><br><span class="line"></span><br><span class="line">a.erase(unique(a.begin(), a.end()), a.end());</span><br></pre></td></tr></table></figure>
这里unique实现的操作是将a容器中的重复元素放置于容器的后面，并且返回去重后容器的尾端点<br>代码实现unique（没有实现放置重复元素于后的功能）（双指针）：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::<span class="function">iterator <span class="title">unique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!i  a[i] != a[i - <span class="number">1</span>])</span><br><span class="line">            a[j++] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.begin() + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如何快速求出这些数字离散化后映射的数字  （使用二分）<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = a.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt;= x)</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;<span class="comment">//映射到从0开始的自然数</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言中的方括号</title>
    <url>/grammar/c-c/263.html</url>
    <content><![CDATA[<p>方括号的实际意义</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; *(*((a+<span class="number">1</span>)+<span class="number">1</span>)) &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; *(a+<span class="number">1</span>)[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出： 7 7<br>a[n] 等价于 *(a+1)<br>(a+n)[x] 等价于 *((a+n)+x)<br>*(a+n)[x] 等价于 *(*((a+n)+x))<br>emm，有趣。(优先级得记好)</p>
]]></content>
      <categories>
        <category>语法</category>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/algorithm/basic-algorithm/255.html</url>
    <content><![CDATA[<p>位运算操作符介绍，原码、反码、补码相关，位运算常用操作</p>
<a id="more"></a>

<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><ul>
<li>&amp; 按位与：同1则1 其余0 </li>
<li>| 按位或：有1则1 都0则0</li>
<li>^ 按位异或：同0 异1 </li>
<li>~ 按位取反：0变1 1变0</li>
<li>&lt;&lt; 左移：<code>左移 n位 = \* 2^n</code></li>
<li>&gt;&gt; 右移：<code>右移 n位 = / 2^n</code> （带符号右移 正数右移后高位补0 负数右移后高位补1）</li>
</ul>
<h2 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h2><p>计算储存整型数时 符号位（最高位）0代表正数 1代表负数 </p>
<p><code>int</code> 型可以储存 <code>[-2^32, 2^32-1]</code></p>
<p>原码：符号位 + 真值绝对值的二进制数</p>
<p>反码：</p>
<ol>
<li>正整数的反码是它本身</li>
<li>负整数的反码是 符号位为 1 + 真值绝对值的二进制数各位取反 </li>
</ol>
<p>补码：</p>
<ol>
<li>正整数的补码是它本身</li>
<li>负整数的补码是 符号位为 1 + 真值绝对值的二进制数各位取反再加一 （即在反码的基础上+1）</li>
</ol>
<p>注：在计算机底层没有减法操作，因此计算机用补码的方式储存负数 </p>
<p>例：设 <code>x = 1</code> 原码为 <code>00000000000000000000000000000001</code></p>
<p><code>~x</code> 为 <code>11111111111111111111111111111110</code></p>
<p><code>-x = 0 - x</code> </p>
<p>0的二进制数为 <code>00000000000000000000000000000000</code> </p>
<p>（在不存在的高一位 借1） <code>-x = 100000000000000000000000000000000 - x = ~x + 1</code></p>
<h2 id="常用的几个操作"><a href="#常用的几个操作" class="headerlink" title="常用的几个操作"></a>常用的几个操作</h2><ol>
<li><p>求n的二进制数最后一位</p>
<p>n &amp; 1</p>
</li>
<li><p>求n的二进制数第k位是多少</p>
<p>n &gt;&gt; k &amp; 1<br>/* n的第k位指从右往左由 0 开始计位 */</p>
</li>
<li><p>lowbit (x) 操作 返回x的最后一位1 （100100 则返回 100）</p>
<p>x &amp; -x<br>/* x &amp; (~x + 1) */</p>
</li>
</ol>
<p>假设 x 为 1010…10000 </p>
<p>~x = 0101…01111 </p>
<p>~x + 1 = 0101…10000 </p>
<p>x &amp; ~x+1 后 为 0000…10000</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针算法</title>
    <url>/algorithm/basic-algorithm/157.html</url>
    <content><![CDATA[<p>双指针算法的思路</p>
<a id="more"></a>
<p>一类是两个指针指向两个序列，用来维护两个序列的某种顺序，在归并排序中，区间合并使用的算法即是双指针算法</p>
<p>另一类是两个指针指向同一个序列，在快速排序中的划分的过程就是双指针算法</p>
<p>朴素算法（暴力）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (check(j, i))</span><br><span class="line">            <span class="comment">//逻辑</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>双指针：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; check(j, i))</span><br><span class="line">    &#123;</span><br><span class="line">        j++;</span><br><span class="line">	<span class="comment">// 题目逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是双指针算法的具体逻辑</p>
<p>在解题时可以将时间复杂度O(n^2)的问题优化到O(n)</p>
<p>入手时可以先从暴力角度分析，找出暴力做法后进行优化，寻找两个数组的单调性</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>差分</title>
    <url>/algorithm/basic-algorithm/118.html</url>
    <content><![CDATA[<p>差分法的一二维实例与理解</p>
<a id="more"></a>
<h2 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h2><p>前缀和与差分为<strong>逆运算</strong></p>
<p>数组a[N]为数据组</p>
<p>数组b[N],s[N]进行两种运算</p>
<p>前缀和运算:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123; </span><br><span class="line">    s[i] += a[i] + a[i - <span class="number">1</span>]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>差分运算：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    b[i] = a[i] - a[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（大概是这个意思吧···）</p>
<hr>
<p>两个数组a[N],b[N]</p>
<p>满足a[i]=b[1]+b[2]+b[3]+···+b[i]，则称a数组为b数组前缀和数组，b为a差分数组</p>
<p>（构造方法：b[1]=a[1],b[2]=a[2]-a[1],b[3]=a[3]-a[2]···）</p>
<p>但是构造差分数组的过程并不重要(存在).</p>
<hr>
<p>实现若干次将一个数组a[N]的[l,r]区间内的数加c</p>
<p>不使用前缀和 差分需要O(n)复杂度 使用则只需要O(1)时间复杂度</p>
<p>将a[N]数组的每一个数字假设为0,b[N]也同理</p>
<p>将原先a[N]中每一个数字如：a[i]，都看作是在b[i,i]插入了a[i]，因此差分数组的构造则可省略</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只需要这样一个插入函数，即可实现算法.</p>
<hr>
<p>综上所述</p>
<p>我习惯于构造一个全零记录数组.</p>
<p>记录[l,r]区间上放c的操作</p>
<p>最后前缀和运算后与数据数组相加</p>
<h2 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h2><p>同理于一维差分.</p>
<p>仍为创建一个全0数组假设其为差分数组 b[N][N]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将数据读入a[N][N]中，同样以一维数组的方式insert入b[N][N]中</p>
<p>再实现若干次将[x1,x2]到[x2,y2]作为两个对角的矩形区间内的数加c的操作</p>
<p>最后同样是将差分数组b进行前缀和运算</p>
<hr>
<p>综上所述</p>
<p>我习惯创建一个记录数组</p>
<p>记录操作</p>
<p>最后再将记录数组求前缀和与原数据数组相加</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二分</title>
    <url>/algorithm/basic-algorithm/112.html</url>
    <content><![CDATA[<p>二分整型与浮点模板</p>
<a id="more"></a>

<h3 id="2021-4-5-更新"><a href="#2021-4-5-更新" class="headerlink" title="2021.4.5 更新"></a>2021.4.5 更新</h3><p>重新复习，同样是 yxc 的整数二分模板（同样是二分条件可以将总区间一分为二，题目一般是查询左区间的右端点或者右区间的左端点），但特殊情况下不查询一个端点，查询的是一个区间，查询区间的左端点即查询一般情况下右区间的左端点，查询区间的右端点即查询一般情况下左区间的右端点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//整数二分模板</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">//性质判断函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid))			<span class="comment">//mid 在右区间中</span></span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span>				   <span class="comment">//mid 在左区间中</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125; <span class="comment">//[l,r]=&gt;[l,mid],[mid+1,r]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">//check ture为l = mid时mid = ( l + r + 1) / 2;</span></span><br><span class="line">        <span class="keyword">if</span> (check(mid))		<span class="comment">//mid 在左区间中</span></span><br><span class="line">            l = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid - <span class="number">1</span>;	<span class="comment">//mid 在右区间中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125; <span class="comment">//[l,r]=&gt;[l,mid-1],[mid,r]</span></span><br><span class="line"><span class="comment">//浮点数二分模板</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">bsearch3</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)<span class="comment">//eps为题目所给精度 （可以往后推几位</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid))</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l; <span class="comment">//r也可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>高精度</title>
    <url>/algorithm/basic-algorithm/110.html</url>
    <content><![CDATA[<p>高精度算法 四则运算模板</p>
<a id="more"></a>
<h2 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size()  i &lt; B.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= A.size())</span><br><span class="line">            t += A\[i\];</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= B.size())</span><br><span class="line">            t += B\[i\];</span><br><span class="line">        C.push\_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t)</span><br><span class="line">        C.push\_back(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        A.push\_back(a\[i\] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        B.push\_back(b\[i\] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">auto</span> C = add(A, B); <span class="comment">//vector&lt;int&gt;C=add(A,B);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C\[i\]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Subtract"><a href="#Subtract" class="headerlink" title="Subtract"></a>Subtract</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.size() != B.size())</span><br><span class="line">        <span class="keyword">return</span> A.size() &gt; B.size();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = A.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (A\[i\] != B\[i\])</span><br><span class="line">                <span class="keyword">return</span> A\[i\] &gt; B\[i\];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t = A\[i\] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.size())</span><br><span class="line">            t -= B\[i\];</span><br><span class="line">        C.push\_back((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>)</span><br><span class="line">            t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>)</span><br><span class="line">        C.pop\_back();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        A.push\_back(a\[i\] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        B.push\_back(b\[i\] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (cmp(A, B))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> C = sub(A, B);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = C.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C\[i\]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> C = sub(B, A);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = C.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C\[i\]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Divide"><a href="#Divide" class="headerlink" title="Divide"></a>Divide</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">div</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        r = r \* <span class="number">10</span> + A\[i\];</span><br><span class="line">        C.push\_back(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(C.begin(), C.end());</span><br><span class="line">    <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>)</span><br><span class="line">        C.pop\_back();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="keyword">int</span> b, r = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        A.push\_back(a\[i\] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">auto</span> C = div(A, b, r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C\[i\]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Multiply"><a href="#Multiply" class="headerlink" title="Multiply"></a>Multiply</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size()  t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.size())</span><br><span class="line">            t += A\[i\] \* b;</span><br><span class="line">        C.push\_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        A.push\_back(a\[i\] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">auto</span> C = mul(A, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C\[i\]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/algorithm/basic-algorithm/106.html</url>
    <content><![CDATA[<p>几个排序方式的模板</p>
<a id="more"></a>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>],n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n - i; j++)</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>])</span><br><span class="line">                swap(a[j], a[j + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> x = a[(l + r + <span class="number">1</span>) / <span class="number">2</span>], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>; <span class="comment">//int x=a[(l+r)/2]</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (a[++i] &lt; x);</span><br><span class="line">        <span class="keyword">while</span> (a[--j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">            swap(a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    quicksort(l, i - <span class="number">1</span>); <span class="comment">//quicksort(l,j);</span></span><br><span class="line">    quicksort(i, r);     <span class="comment">//quicksort(j+1,r);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    quicksort(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], tem[N], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    mergesort(a, l, mid), mergesort(a, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; a[j])</span><br><span class="line">            tem[k++] = a[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tem[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">        tem[k++] = a[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r)</span><br><span class="line">        tem[k++] = a[j++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        a[l + i] = tem[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    mergesort(a, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和</title>
    <url>/algorithm/basic-algorithm/102.html</url>
    <content><![CDATA[<p>前缀和算法的一二维示例</p>
<a id="more"></a>
<h2 id="l-r-的和-一维-："><a href="#l-r-的和-一维-：" class="headerlink" title="[l,r]的和 (一维)："></a>[l,r]的和 (一维)：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s[<span class="number">100000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">        s[i] += s[i - <span class="number">1</span>] + t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s[r] - s[l - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="子矩阵和-二维-："><a href="#子矩阵和-二维-：" class="headerlink" title="子矩阵和 (二维)："></a>子矩阵和 (二维)：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N][N],s[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,q;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] + a[i][j] - s[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> x1,y1,x2,y2;</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%dn&quot;</span>, s[x2][y2] - s[x1 - <span class="number">1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title>WP Setting Up</title>
    <url>/linux-unix/57.html</url>
    <content><![CDATA[<p>LAMP+WordPress</p>
<a id="more"></a>
<h2 id="Apt-get"><a href="#Apt-get" class="headerlink" title="Apt-get"></a>Apt-get</h2><p>apt-get install apache</p>
<p>libapache2-mod-php php-mysql php-mcrypt php-curl php-gd php-mbstring php-simplexml ···</p>
<p>mysql</p>
<p>systemctl restart ···</p>
<h2 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h2><p>emm···</p>
<h2 id="MySQL-权限"><a href="#MySQL-权限" class="headerlink" title="MySQL+权限"></a>MySQL+权限</h2><p>service mysqld start</p>
<p>mysql_secure_installation</p>
<p>chown -r www-data /*/*/html</p>
<p>chmod -R 777 /var/www/html/<br>mysql -u root -p<br>CREATE DATABASE WordPressTest;<br>SET PASSWORD FOR WordPressTestUser= PASSWORD(“passwordtest”);<br>GRANT ALL PRIVILEGES ON WordPressTest.* TO WordPressTestUser IDENTIFIED BY”passwordtest”;<br>FLUSH PRIVILEGES;</p>
<p>(非安全部署)</p>
<h2 id="WP"><a href="#WP" class="headerlink" title="WP"></a>WP</h2><p>wp-config.php mysql数据填入</p>
<p>register</p>
<h2 id="伪静态开启"><a href="#伪静态开启" class="headerlink" title="伪静态开启"></a>伪静态开启</h2><p>sudu a2enmod</p>
<p>rewrite</p>
<p>改apache2.conf</p>
<p>参考：<a href="https://blog.csdn.net/zziahgf/article/details/80348744">https://blog.csdn.net/zziahgf/article/details/80348744</a></p>
<p>重启 apache</p>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      <categories>
        <category>Linux/Unix</category>
      </categories>
      <tags>
        <tag>Linux/Unix</tag>
      </tags>
  </entry>
  <entry>
    <title>往昔的你有所盼望，如今的我仍在梦想</title>
    <url>/me/life/54.html</url>
    <content><![CDATA[<p>迷茫，懒惰，轻易放手的我习以为常</p>
<p>昨夜的你曾在枕旁</p>
<p>于我耳边呢喃着你那肆意的向往</p>
<p>今晨的我踏上了寻找的征途</p>
<p>在这尘埃一隅，记录沿途星芒</p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>The Real Folk Blues</title>
    <url>/me/anime/313.html</url>
    <content><![CDATA[<p>COWBOY BEBOP</p>
<a id="more"></a>
<p>菅野洋子 x 渡边信一郎<br>归于平淡亦或者做出了结<br>每个人都有自己的Folk Blues.<br>SEE YOU COWBOY COWGIRL<br>  SOMEDAY,SOMEWHERE !</p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>Anime</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>Anime</tag>
      </tags>
  </entry>
  <entry>
    <title>关于我</title>
    <url>/about/index.html</url>
    <content><![CDATA[<p>&nbsp;</p>
<h1 id="在追寻自我的路上迷路的人"><a href="#在追寻自我的路上迷路的人" class="headerlink" title="在追寻自我的路上迷路的人"></a>在追寻自我的路上迷路的人</h1><h2 id="性格"><a href="#性格" class="headerlink" title="性格"></a>性格</h2><ol>
<li>情绪控制差，易怒</li>
<li>喜欢阴阳别人</li>
<li>三分钟热度</li>
<li>极度自恋</li>
</ol>
<h2 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h2><ul>
<li>QQ: 1007950695</li>
<li>WeChat: ymzyangmaozhen</li>
<li>Blizzard: Wool#5502</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>分类</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>留言板</title>
    <url>/guestbook/index.html</url>
    <content><![CDATA[<h1 id="想和我说什么，写在下面吧"><a href="#想和我说什么，写在下面吧" class="headerlink" title="想和我说什么，写在下面吧"></a><strong>想和我说什么，写在下面吧</strong></h1>]]></content>
  </entry>
  <entry>
    <title>前端实验</title>
    <url>/html/index.html</url>
    <content><![CDATA[<h1 id="写的一些html页面"><a href="#写的一些html页面" class="headerlink" title="写的一些html页面"></a>写的一些html页面</h1><ul>
<li><p><a href="/html/first/index.html">第一个网页</a></p>
</li>
<li><p><a href="/html/timer/index.html">简陋计时器</a></p>
</li>
<li><p><a href="/html/jump/index.html">简陋跳转</a></p>
</li>
<li><p><a href="/html/css-div/index.html">简单CSS设计</a></p>
</li>
<li><p><a href="/html/transaction-form/index.html">简单交易表单</a></p>
</li>
<li><p><a href="/html/layout-design/index.html">页面布局</a></p>
</li>
<li><p><a href="/html/schedule/index.html">课程表</a></p>
</li>
<li><p><a href="/html/personal-document/index.html">个人资料表单</a></p>
</li>
<li><p><a href="/html/cover-letter/index.html">个人简历</a></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>标签</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/html/cover-letter/css/1.css</url>
    <content><![CDATA[@charset "utf-8";
/* CSS Document */

*{
	font-family: 'Noto Serif SC', serif;
}

#longtxt{
	font-size: 1em;
	width: 80%;
}

html, body{
    width: 100%;
    height: 100%;
	margin: 0;
}

#main{
	width: 100%;
	height: 100%;
	display: flex;
	justify-content: space-between;
	align-items: center;
	flex-direction: row;
	flex-wrap: nowrap;
}

#document0{
	width: 500px;
	height: 700px;
	min-height: 700px;
	min-width: 500px;
	display: flex;
	justify-content: flex-start;
	align-items: flex-start;
	flex-direction: column;
	flex-wrap: nowrap;
	background-color: steelblue;
	color: white;
}

#head0{
	width: 100%;
	height: 25%;
	position: relative;
	top: 5%;
	display: flex;
	justify-content: space-around;
	align-items: center;
	flex-direction: row;
	flex-wrap: nowrap;
}

#ava{
	width: 30%;
	height: 80%;
	position: relative;
	right: 6%;
	bottom: 15%;
}

#tit{
	width: 60%;
	height: 50%;
	position: relative;
	right: 8%;
	bottom: 10%;
	display: flex;
	justify-content: flex-start;
	align-items: center;
	flex-direction: row;
	flex-wrap: nowrap;
}

#fill1{
	width: 0.7%;
	height: 150%;
	z-index: 1;
	position: relative;
	left: 20%;
	top: 30%;
	background-color: deepskyblue;
}

#st1{
	width: 80%;
	height: 100%;
	position: relative;
	left: 25%;
	display: flex;
	justify-content: center;
	align-items: center;
	flex-direction: column;
	flex-wrap: nowrap;
}


#txt1{
	display: flex;
	position: relative;
	top: 30%;
	justify-content: center;
	align-items: center;
	flex-wrap: nowrap;
	height: 50%;
	font-size: 3em;
}

#txt2{
	position: relative;
	top: 70%;
}

#documents{
	height: 700px;
	width: 1000px;
	min-width: 1000px;
	min-height: 700px;
	display: flex;
	justify-content: flex-start;
	align-items: center;
	flex-direction: row;
	flex-wrap: nowrap;
}

#textarea{
	height: 100%;
	width: 100%;
	display: flex;
	justify-content: flex-start;
	align-items: flex-start;
	flex-direction: column;
	flex-wrap: nowrap;
}

#icon1{
	width: 5.5%;
	position: relative;
	left: 0.5%;
}

#icon2{
	width: 10%;
}

#icon3{
	width: 13%;
	position: relative;
	right: 1.5%;
}

#icon4{
	width: 4.5%;
	position: relative;
	right: 1%;
}

#icon5{
	width: 5.5%;
	position: relative;
	right: 0.5%;
}

.tit1{
	display: flex;
	justify-content: center;
	align-items: center;
	flex-direction: row;
	height: 50%;
	width: 100%;
}
#document1{
	width: 100%;
	height: 28%;
	display: flex;
	justify-content: center;
	align-items: center;
	flex-direction: column;
	border-bottom-style: dotted;
	border-bottom-width: medium;
	border-bottom-color: lightskyblue;
}

#document2{
	width: 100%;
	height: 19%;
	display: flex;
	justify-content: flex-start;
	align-items: center;
	flex-direction: row;
	border-bottom-style: dotted;
	border-bottom-width: medium;
	border-bottom-color: lightskyblue;
}

#document3{
	width: 100%;
	height: 24%;
	display: flex;
	justify-content: flex-start;
	align-items: center;
	flex-direction: column;
	border-bottom-style: dotted;
	border-bottom-width: medium;
	border-bottom-color: lightskyblue;
}

#document4{
	width: 100%;
	height: 20%;
	display: flex;
	justify-content: flex-start;
	align-items: center;
	flex-direction: column;
}

#document21{
	width: 60%;
	height: 95%;
	display: flex;
	justify-content: center;
	align-items: center;
	flex-direction: column;
	border-right-style: dotted;
	border-right-width: medium;
	border-right-color: lightskyblue;
}

#document22{
	position: relative;
	left: 1%;
	display: flex;
	justify-content: center;
	align-items: center;
	flex-direction: column;
	width: 37%;
	height: 95%;
}

#img1{
	width: 7%;
}

.inforimg{
	width: 12%;
}

#informain{
	width: 100%;
	height: 80%;
	display: flex;
	justify-content: space-around;
	align-items: center;
	flex-direction: column;
	flex-wrap: nowrap;
}

.inforcontent{
	width: 51%;
	height: 15%;
	display: flex;
	justify-content: flex-start;
	align-items: center;
	flex-direction: row;
	flex-wrap: nowrap;
	
}

a:link{color:lightskyblue;}

a:visited{color:lightskyblue;}

.inforhr{
	width: 80%;
	margin: 0 auto;
	border: 0;
	height: 0.8px;
	background-image: linear-gradient(to right, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.75), rgba(0, 0, 0, 0));
}

.inforhr0{
	width: 90%;
	margin: 0 auto;
	border: 0;
	height: 2px;
	background-image: linear-gradient(to right, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.75), rgba(0, 0, 0, 0));
}

#infor{
	width: 100%;
	height: 40%;
	position: relative;
	top: 10%;	
}

#infortit{
	display: flex;
	justify-content: center;
	align-items: center;
	flex-direction: row;
	flex-wrap: nowrap;
	width: 100%;
	height: 20%;
}

#qr{
	width: 100%;
	height: 25%;
	position: relative;
	top: 10%;
	display: flex;
	justify-content: space-around;
	align-items: center;
	flex-direction: row;
	flex-wrap: nowrap;
}

#qr1{
	position: relative;
	left: 5%;
	width: 30%;
	opacity: 80%;
}

#qr2{
	position: relative;
	right: 5%;
	width: 30%;
	opacity: 80%;
}
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/html/css-div/css/1.css</url>
    <content><![CDATA[*{
	margin: 0;
	padding: 0;
	font-family: 'Noto Serif SC', serif;
}
html, body{
	height: 100%;
	width: 100%;
}
#main{
	height: 100%;
	width: 100%;
	display: flex;
	justify-content: center;
	align-items: center;
	flex-direction: column;
}
#mainhd{
	position: relative;
	bottom: 5%;
	font-size: 1.9em;
}
#nav{
	position: relative;
	bottom: 2%;
	display: flex;
	justify-content: center;
	align-items: center;
	flex-direction: row;
	width: 100%;
	height: 5%;
	background-color: deepskyblue;
	font-size: 1.2em;
}
#ul{
	display: flex;
	justify-content: center;
	align-items: center;
	flex-direction: row;
	list-style: none;
	width: 100%;
	height: auto;
	margin-right: 30%;
}
li{
	margin: 0 7%;
	width: 5;
}
li:hover{
	background-color: lightblue;
}
#art{
	display: flex;
	justify-content: center;
	align-items: center;
	flex-direction: row;
	height: 70%;
	width: 100%;
}
#mainart{
	display: flex;
	justify-content: center;
	align-items: center;
	flex-direction: column;
	height: 100%;
	width: 60%;
}
.content{
	display: flex;
	justify-content: space-between;
	align-items: center;
	flex-direction: column;
	width: 100%;
	height: 45%;
	border-bottom-style: dashed;
	border-style: solid;
	border-color: deepskyblue;
	margin: 2%;
}
.h{
	width: 90%;
	padding: 2%;
	border-bottom-style: dashed;
	border-color: deepskyblue;
	font-size: 1.1em;
}
.art1{
	font-size: 0.9em;
	width: 90%;
	padding: 2%;
	border-bottom-style: solid;
	border-color: deepskyblue;
}
.foot1{
	font-size: 0.5em;
	padding: 2%;
	width: 90%;
}
aside{
	display: flex;
	justify-content: flex-start;
	align-items: flex-start;
	flex-direction: column;
	height: 98%;
	width: 15%;
	margin-left: 2%;
	background-color: lightgrey;
}
#as1{
	font-size: 1.2em;
	margin: 5% 0 0 5%;	
}
#as2{
	margin: 5% 0 0 5%;	
}
#mainfoot{
	display: flex;
	justify-content: center;
	align-items: center;
	position: relative;
	top:3%;
	width: 100%;
	height: 5%;
	border-top-style: solid;
	border-top-color: cadetblue;
}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/html/jump/js/1.js</url>
    <content><![CDATA[// JavaScript Document
function jump(){
	var select = document.getElementById("list");
	var num = select.selectedIndex;
	var text = document.getElementById("site");
	text.value = select[num].value;
}



function jump1() {
	var site = document.getElementById("site");
	window.open(site.value, "_self");
}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/html/layout-design/css/1.css</url>
    <content><![CDATA[@charset "utf-8";
/* CSS Document */
@media screen and (min-width: 960px){
	*{
		padding: 0;
		margin: 0;
		font-family: 'Noto Serif SC', serif;
	}
	html, body{
		height: 100%;
		width: 100%;
		margin: 0;
		background-image: url(https://www.woolym.com/html/layout-design/img/bg.jpg);
		background-color: lightblue;
		background-size: cover;
		background-repeat: no-repeat;
		background-position:center;
		background-attachment: fixed;
	}
	#div0{
		height: 100%;
		width: 100%;
		display: flex;
		justify-content: center;
		align-items: center;
		flex-direction: column;
	}
	header{
		display: flex;
		justify-content: center;
		align-items: center;
		flex-direction: column; 
		height: 12%;
		width: 100%;
		position: relative;
		top: 5%;
		background-color: white;
		opacity: 0.8;
	}
	main{
		width: 100%;
		height: 66%;
		display: flex;
		justify-content: space-around;
		align-items: center;
		flex-direction: row;
		flex-wrap: nowrap;
	}
	article{
		display: flex;
		justify-content: center;
		align-items: center;
		width: 30%;
		height: 90%;
		background-image: url(https://www.woolym.com/html/personal-document/img/bg2.png);
		border-radius: 1em;
		text-overflow: ellipsis;
		overflow: hidden;
	}
	aside{
		display: flex;
		justify-content: center;
		align-items: center;
		flex-direction: column;
		width: 30%;
		height: 90%;
		background-image: url(https://www.woolym.com/html/personal-document/img/bg2.png);
		border-radius: 1em;
	}
	nav{
		text-align: center;
		width: 100%;
		height: 12%;
		display: flex;
		justify-content: space-around;
		align-items: center;
		flex-direction: row;
		flex-wrap: nowrap;
		position: relative;
		top: 4.5%;
	}
	footer{
		width: 97%;
		height: 10%;
		background-image: url(https://www.woolym.com/html/personal-document/img/bg2.png);
		border-radius: 1em;
		position: relative;
		bottom: 1.5%;
		display: flex;
		justify-content: center;
		align-items: center;
		flex-direction: column; 
	}
	#img1{
		height: 90%;
		width: 90%;
		border-radius: 1em;
	}
	#title1{
		font-size: 1.5em;
		color: aliceblue;
		font-weight: bold;
	}
	.title0{
		font-size: 2em;
		color:rgba(207,80,20,1.00);
		position: relative;
		
		font-weight: bolder;
	}
	a{
		font-size: 2em;
		list-style: none;
		background-image: url(https://www.woolym.com/html/personal-document/img/bg2.png);
		border-radius: 1em;
		color:rgba(128,0,197,1.00);
		font-weight: bold;
	}
	a:hover{
		background-image: none;
		color:aqua;
		background-color:rgba(78,124,221,1.00);
	}
	#gun{
		font-size: 2.7em;
		color:rgba(244,61,249,1.00);
	}
	#article1{
		font-size: 1.5em;
		color:rgba(14,58,9,1.00);
		font-weight: bold;
	}
	#article2{
		font-size: 1.5em;
		color:rgba(20,45,105,1.00);
		font-weight: bold;
	}
}
@media screen and (max-width: 960px){
	*{
		padding: 0;
		margin: 0;
		font-family: 'Noto Serif SC', serif;
	}
	html, body{
		height: 100%;
		width: 100%;
		margin: 0;
		background-image: url(https://www.woolym.com/html/layout-design/img/bg.jpg);
		background-color: lightblue;
		background-size: cover;
		background-repeat: no-repeat;
		background-position:center;
		background-attachment: fixed;
	}
	#div0{
		height: 100%;
		width: 100%;
		display: flex;
		justify-content: center;
		align-items: center;
		flex-direction: column;
	}
	header{
		display: flex;
		justify-content: center;
		align-items: center;
		flex-direction: column; 
		height: 12%;
		width: 100%;
		position: relative;
		top: 5%;
		background-color: white;
		opacity: 0.8;
	}
	main{
		width: 100%;
		height: 66%;
		display: flex;
		justify-content: space-around;
		align-items: center;
		flex-direction: row;
		flex-wrap: nowrap;
	}
	article{
		display: flex;
		justify-content: center;
		align-items: center;
		width: 30%;
		height: 90%;
		background-image: url(https://www.woolym.com/html/personal-document/img/bg2.png);
		border-radius: 1em;
	}
	aside{
		display: flex;
		justify-content: center;
		align-items: center;
		flex-direction: column;
		width: 30%;
		height: 90%;
		background-image: url(https://www.woolym.com/html/personal-document/img/bg2.png);
		border-radius: 1em;
	}
	nav{
		text-align: center;
		width: 100%;
		height: 12%;
		display: flex;
		justify-content: space-around;
		align-items: center;
		flex-direction: row;
		flex-wrap: nowrap;
		position: relative;
		top: 4.5%;
	}
	footer{
		width: 97%;
		height: 10%;
		background-image: url(https://www.woolym.com/html/personal-document/img/bg2.png);
		border-radius: 1em;
		position: relative;
		bottom: 1.5%;
		display: flex;
		justify-content: center;
		align-items: center;
		flex-direction: column; 
	}
	#img1{
		height: 90%;
		width: 90%;
		border-radius: 1em;
	}
	#title1{
		font-size: 0.8em;
		color: aliceblue;
		font-weight: bold;
	}
	.title0{
		font-size: 1.7em;
		color:rgba(207,80,20,1.00);
		font-weight: bolder;
	}
	a{
		font-size: 0.9em;
		list-style: none;
		background-image: url(https://www.woolym.com/html/personal-document/img/bg2.png);
		border-radius: 1em;
		color:rgba(128,0,197,1.00);
		font-weight: bold;
	}
	a:hover{
		background-image: none;
		color:aqua;
		background-color:rgba(78,124,221,1.00);
	}
	#gun{
		font-size: 2em;
		color:rgba(244,61,249,1.00);
	}
	#article1{
		font-size: 0.8em;
		color:rgba(14,58,9,1.00);
		font-weight: bold;
	}
	#article2{
		font-size: 0.8em;
		color:rgba(20,45,105,1.00);
		font-weight: bold;
	}
}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/html/personal-document/css/1.css</url>
    <content><![CDATA[@charset "utf-8";
/* CSS Document */
@media screen and (min-width: 960px){
	html, body{
    	width: 100%;
    	height: 100%;
		margin: 0;
		background-image: url(https://www.woolym.com/html/personal-document/img/bg.jpg);
		background-color: lightblue;
		background-size: cover;
		background-repeat: no-repeat;
		background-position:center;
		background-attachment: fixed;
	}
	*{
		padding: 0;
		margin: 0;
	}
	#guestbook{
		height: 100%;
		width: 100%;
		resize: none;
	}
	#guesttd{
		height: 7.5em;
	}
	#div0{
		display: flex;
		justify-content: center;
		align-items: center;
		flex-direction: column;
		width: 100%;
		height: 100%;
	}
	#main{
		position: relative;
		z-index: 10;
		border-collapse: separate;
		border-spacing: 1.56em 0.48em;
		top: 0.44em;
		height: 100%;
		width: 100%;
		background-image: url(https://www.woolym.com/html/personal-document/img/bg1.png);
		border-radius: 1.25em;
	}
	#table1{
		height: 100%;
		width: 100%;
	}
	form{
		height: 70%;
		width: 30%;
	}
	th{
		text-align: right;
		font-family: 'Noto Serif SC', serif;
		color: azure;
		font-size: 1.0em;
	}
	td{
		color: azure;
		font-size: 1.0em;
	}
	.sexwidth{
		width: 3.125em;
	}
	.buttontd{
		width: 9.375em;
		text-align: center;
	}
	.button{
		height: 1.875em;
		width: 4.5em;
	}
	*{
		font-family: 'Noto Sans SC', sans-serif;
	}
	caption{
		z-index: 10;
		text-decoration:underline;
		position: relative;
		bottom: 1em;
		font-size: 1.9em;
		font-family: 'Noto Serif SC', serif;
		color: aliceblue;
	}
	.input2{
		width: 80%;
	}
	.input1{
		width: 45%;
	}
	#div2{
		color: whitesmoke;
		position: absolute;
		z-index: 10;
		font-size: 1.2em;
		bottom: 1em;
		font-family: 'Noto Serif SC', serif;
	}
	a{
		color: aqua;
	}
	span{
		color: aliceblue;
	}
	#th1{
		font-size: 0.8em;
	}
	marquee{
		font-size: 2em;
	}
}
@media screen and (max-width: 960px){
	html, body{
    	width: 100%;
    	height: 100%;
		margin: 0;
		background-image: url(https://www.woolym.com/html/personal-document/img/bg.jpg);
		background-color: lightblue;
		background-size: cover;
		background-repeat: no-repeat;
		background-position:center;
		background-attachment: fixed;
	}
	*{
		padding: 0;
		margin: 0;
	}
	#guestbook{
		height: 100%;
		width: 100%;
		resize: none;
	}
	#guesttd{
		height: 7.5em;
	}
	#div0{
		display: flex;
		justify-content:center;
		align-items:center;
		flex-direction: column;
		width: 100%;
		height: 100%;
	}
	#main{
		position: relative;
		z-index: 10;
		border-collapse: separate;
		border-spacing: 1.5625em 0.75em;
		bottom: 0.5em;
		height: 100%;
		width: 100%;
		background-image: url(https://www.woolym.com/html/personal-document/img/bg1.png);
		border-radius: 1.25em;
	}
	#table1{
		height: 100%;
		width: 100%;
	}
	form{
		height: 70%;
		width: 80%;
	}
	th{
		text-align: right;
		font-family: 'Noto Serif SC', serif;
		color: azure;
		font-size: 1.0em;
	}
	td{
		color: azure;
		font-size: 1.0em;
	}
	.sexwidth{
		width: 3.125em;
	}
	.buttontd{
		width: 9.375em;
		text-align: center;
	}
	.button{
		height: 1.875em;
		width: 4.5em;
	}
	*{
		font-family: 'Noto Sans SC', sans-serif;
	}
	caption{
		z-index: 10;
		text-decoration:underline;
		position: relative;
		bottom: 1em;
		font-size: 1.9em;
		font-family: 'Noto Serif SC', serif;
		color: aliceblue;
	}
	.input2{
		width: 80%;
	}
	.input1{
		width: 45%;
	}
	#div2{
		color: whitesmoke;
		position: absolute;
		z-index: 10;
		font-size: 1.2em;
		top: 0.7em;
		left: 0.7em;
		font-family: 'Noto Serif SC', serif;
	}
	a{
		color: lightsteelblue;
	}
	span{
		color: aliceblue;
	}
	#th1{
		font-size: 0.8em;
	}
	marquee{
		font-size: 2em;
	}
}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/html/timer/js/1.js</url>
    <content><![CDATA[// JavaScript Document
var time0 = 0;
var timecount;

var a;

var flag = 0;

function start1(){
	a = document.getElementById("count");
	if(flag == 0){
		start2(1);
		flag = 1;
	}
}

function start2(x){
	if(x == 1){
		setTimeout("function(){time0 += 1;}", 1000);
	}
	else{
		time0 += 1;
	}
	a.value = time0;
	timecount = setTimeout("start2(0)", 1000);
}

function stop1(){
	flag = 0;
	clearTimeout(timecount);
}
	
function clear1(){
	stop1();
	time0 = 0;
	a.value = time0;
}
	
]]></content>
  </entry>
</search>
